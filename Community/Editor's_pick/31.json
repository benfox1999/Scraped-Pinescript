{"created":"2024-02-05T15:45:43.783464Z","extra":{"kind":"study","sourceInputsCount":1},"lastVersionMaj":"2.0","scriptAccess":"open_no_auth","scriptName":"Volume Profile with a few polylines","source":"fi(ki)=>'ra' \n// © fikira This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/ \n// @version=5 \n\nindicator('Volume Profile with a few polylines', max_lines_count = 500, max_boxes_count = 500, max_bars_back=2000, max_polylines_count=100, overlay=true)\n\n_                                                                                                                                                                                                                                                                                                                                                                = '\n                                                                       Settings\n                                                                     ------------                                                                                                                                                                                                                                                                                     '\n                                                                 \nsp1         ='                                          '              , sp2 =                         '                                     '\nsrc         = input.source(          close              ,              'source'                                                              )\nmtV         = input.bool  (          true      , sp2    +         'Volume * currency'                                                        \n ,tooltip   =                                             'Example BTCUSD -> volume in USD'                                                  )\nbarsBack    = input.int   (          20000              ,          'Amount of bars'                            , maxval=50000                )\niStep       = input.string(         'Round'             ,                 ''                   , group ='Round', options=['Round', 'Step'])\nmlt         = input.int   (            0                ,              'Round'                 , group ='Round', minval=  -8    , maxval=  4  \n ,tooltip   =                'Example: 123456.789 \\n  0->123456.789\\n  1->123456.79\\n  2->123456.8\\n  3->123457\\n-1->123460\\n-2->123500'     ) \nstep        = input.float (            1                                                       , group ='Round'                              )\noffset      = input.int   (           200               ,              'Offset'                , group ='display Volume Profile', maxval=500 ) \nwidth       = input.int   (           205               ,       'Max width Volume Profile'     , group ='display Volume Profile'             ) \ncReg        = input.color(color.rgb(178, 181, 190, 45),                sp1                   , group ='display Volume Profile', inline='c' ) \ncH_1        = input.color(color.rgb(255,   0,   0, 25),                 ''                   , group ='display Volume Profile', inline='c' ) \ncH_2        = input.color(color.rgb(255, 153,   0, 25),                 ''                   , group ='display Volume Profile', inline='c' ) \ncH_3        = input.color(color.rgb(255, 251,   0, 25),                 ''                   , group ='display Volume Profile', inline='c' ) \ns           = '                            ',s2='                          '\nfillcolor   = input.color(#e6510088,   'fill color'+s , inline='l')\ncurvedInput = input.bool (   false   ,     'curved'  +s2, inline='c')\nclosedInput = input.bool (   false   ,     'closed'     , inline='c')\n\nm           =                                mlt > 0 ? math.pow(10, mlt) : 1\nsrc        := iStep == 'Step' \n           ? math.round(src / step) * step : mlt > 0 \n           ? math.round(src /   m ) *   m  : math.round(src, math.round(math.abs(math.log10(syminfo.mintick)) +mlt)) \n_                                                                                                                                                                                                                                                                                                                                                                = \"\n                                                                         UDT's\n                                                                      ----------                                                                                                                                                                                                                                                                                     \"\n \ntype aCh \n    chart.point[] ch\n\ntype pv \n    float p \n    float v \n_                                                                                                                                                                                                                                                                                                                                                                = \"\n                                                                      Variables\n                                                                     -----------                                                                                                                                                                                                                                                                                      \"\n \nvar originalMap = map  .new <float, float>()                                    \nvar line l1 = line.new(na, na, na, na, color=cH_1, width=2)\nvar line l2 = line.new(na, na, na, na, color=cH_2, width=2)\nvar line l3 = line.new(na, na, na, na, color=cH_3, width=1)\n_                                                                                                                                                                                                                                                                                                                                                                = '\n                                                                      Execution\n                                                                     ------------                                                                                                                                                                                                                                                                                     '\n \nn               =                            bar_index \nbarsBack       := math.min  (barsBack , last_bar_index)                        \n\nif last_bar_index - n <= barsBack\n    originalMap.put(src, nz(originalMap.get(src)) + (volume * (mtV ? src : 1))) \n\ncount = 0\n\nif barstate.islast \n    for poly in polyline.all \n        poly.delete()\n        \n    aPoints = array.from(aCh.new(array.new<chart.point>()))\n    points  = array.new<chart.point>()\n    point2  = array.new<chart.point>()\n    point3  = array.new<chart.point>()\n\n    maxV    = array.from(pv.new(0., 0.), pv.new(0., 0.), pv.new(0., 0.)) \n    maxVol  = 0., maxVpr = 0.\n    maxVl2  = 0., maxVp2 = 0.\n    maxVl3  = 0., maxVp3 = 0.\n\n    if originalMap.size() > 1\n\n        keys = originalMap.keys()\n        kSz  = keys.size()\n        for key in keys\n            value = originalMap.get(key)\n            get0v = maxV.get(0).v \n            get1v = maxV.get(1).v \n            get2v = maxV.get(2).v \n            get0p = maxV.get(0).p \n            get1p = maxV.get(1).p \n            get2p = maxV.get(2).p \n            // fetching 3 highest volume values\n            switch \n                value > get0v =>\n                    maxV.set(0, pv.new(key, value))\n                    if get0v > get1v\n                        maxV.set(1, pv.new(get0p, get0v))\n                        if get1v > get2v\n                            maxV.set(2, pv.new(get1p, get1v))\n                    else if get0v > get2v\n                        maxV.set(2, pv.new(get0p, get0v))\n                value > get1v =>\n                    maxV.set(1, pv.new(key, value))\n                    if get1v > get2v\n                        maxV.set(2, pv.new(get1p, get1v))\n                value > get2v =>\n                    maxV.set(2, pv.new(key, value))\n\n        w = width / maxV.get(0).v  // max width                                                                               \n        keys.sort() // sort keys -> 'price' is sorted\n        for j     = 0 to kSz -1\n            key   = keys.get(j)\n            value = originalMap.get(key)\n            c     = 0\n            get   = aPoints.get(c)\n            if  get.ch.size() < 9999 // max limit is 10K points per polyline -> check every time the array.size()\n                get.ch.push(chart.point.from_index(n + offset, key)) \n                get.ch.push(chart.point.from_index(n + offset - math.round(value * w), key)) \n                get.ch.push(chart.point.from_index(n + offset, key)) \n                count += 3\n            else \n                aPoints.unshift(aCh.new(array.new<chart.point>())) // when full, add another array.new<chart.point>()\n                c += 1\n        // display 3 largest volume values with 3x line.new()\n        l1.set_xy1(math.max(0, n + offset                                ), maxV.get(0).p)\n        l1.set_xy2(math.max(0, n + offset - math.round(maxV.get(0).v * w)), maxV.get(0).p)\n        l2.set_xy1(math.max(0, n + offset                                ), maxV.get(1).p)\n        l2.set_xy2(math.max(0, n + offset - math.round(maxV.get(1).v * w)), maxV.get(1).p)\n        l3.set_xy1(math.max(0, n + offset                                ), maxV.get(2).p)\n        l3.set_xy2(math.max(0, n + offset - math.round(maxV.get(2).v * w)), maxV.get(2).p)  \n\n        // draw a polyline from the point of each array.new<chart.point>()\n        for l = 0 to aPoints.size() -1\n            polyline.new(aPoints.get(l).ch, curved = curvedInput, closed = closedInput, line_color = cReg, fill_color = fillcolor)\n\n//plot(count) // uncomment to see the amount of values\n_                                                                                                                                                                                                                                                                                                                                                                = '\n                                                                     ------------                                                                                                                                                                                                                                                                                     '\n ","updated":"2024-02-05T15:45:43.783464Z","version":"2.0"}