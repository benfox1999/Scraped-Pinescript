{"created":"2024-05-16T13:41:45.224932Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"1.0","scriptAccess":"open_no_auth","scriptName":"Ichimoku Theories [LuxAlgo]","source":"// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/\n// © LuxAlgo\n\n//@version=5\nindicator('Ichimoku Theories [LuxAlgo]', 'LuxAlgo - Ichimoku Theories', overlay = true, max_lines_count = 500, max_labels_count = 500, max_polylines_count = 100)\n//---------------------------------------------------------------------------------------------------------------------}\n//CONSTANTS & STRINGS & INPUTS\n//---------------------------------------------------------------------------------------------------------------------{\nBULLISH_LEG                 = 1\nBEARISH_LEG                 = 0\n\nKIHON                       = 'KIHON SUCHI'\nTAITO                       = 'TAITO SUCHI'\n\nHIGHS                       = 'HIGHS'\nLOWS                        = 'LOWS'\nSWINGS                      = 'SWINGS'\nTENKAN                      = 'TENKAN CROSS'\nKIJUN                       = 'KIJUN CROSS'\nKUMO                        = 'KUMO CHANGE'\nWAVE                        = 'WAVES'\n\nWAVE_I                      = 'WAVE I'\nWAVE_V                      = 'WAVE V'\nWAVE_N                      = 'WAVE N'\nWAVE_P                      = 'WAVE P'\nWAVE_Y                      = 'WAVE Y'\nWAVE_W                      = 'WAVE W'\n\nBULLISH                     = 'BULLISH'\nBEARISH                     = 'BEARISH'\n\nEN_SPACE                    = ' '\nEM_SPACE                    = ' '\nFOUR_PER_EM_SPACE           = ' '\nSIX_PER_EM_SPACE            = ' '\nHAIR_SPACE                  = ' '\n\nGREEN                       = #089981\nRED                         = #F23645\n\nICHIMOKU_GROUP              = 'ICHIMOKU KINKŌ HYŌ'\nTIME_GROUP                  = 'TIME THEORY'\nWAVE_GROUP                  = 'WAVE THEORY'\nPRICE_GROUP                 = 'PRICE THEORY'\n\nshowPivotMarksTooltip       = 'Enable/Disable points on swing highs and swing lows.'\npivotLengthTooltip          = 'Number of candles to confirm a swing high or swing low. A higher number detects larger swings.'\nshowIchimokuLinesTooltip    = 'Enable/Disable the 5 Ichimoku lines: kijun sen, tenkan sen, senkou span A & B and chikou span.'\nshowIchimokuKumoTooltip     = 'Enable/Disable the Kumo (cloud). The Kumo is formed by 2 lines: Senkou Span A and Senkou Span B.'\ntenkanSenLengthTooltip      = 'Number of candles for Tenkan Sen calculation.'\nkinjuSenLengthTooltip       = 'Number of candles for the Kijun Sen calculation.'\nsenkouSpanBLengthTooltip    = 'Number of candles for Senkou Span B calculation.'\nichimokunOffsetTooltip      = 'Number of candles for Chikou and Senkou Span calculation. Chikou Span is plotted in the past, Senkou Span A & B in the future.'\nshowTimeForecastTooltip     = 'Enable/Disable time cycle forecast vertical lines. Disable for better performance.'\ntimePatternTooltip          = 'Choose between two patterns: Kihon Suchi (basic numbers) or Taito Suchi (equal numbers).'\ntimeForecastAnchorTooltip   = 'Number of time cycles in the past to anchor the time cycle forecast. The larger the number, the deeper in the past the anchor will be.'\ntimeCycleModeTooltip        = 'Choose from 7 time cycle detection modes: Tenkan Sen cross, Kijun Sen cross, Kumo change between bullish & bearish, swing highs only, swing lows only, both swing highs & lows and wave detection.'\nwaveCyleTooltip             = 'Choose which type of wave to detect from 6 different wave types when time cycle mode is set to WAVES.'\nshowTimeCyclesTooltip       = 'Enable/Disable time cycle horizontal lines. Disable for better performance.'\nmaximumTimeCyclesTooltip    = 'Maximum number of time cycles to display.'\nbasicWavesTooltip           = 'Enable/Disable display of basic waves, all at once or one at a time. Disable for better performance.'\ncomplexWavesTooltip         = 'Enable/Disable complex wave display, all at once or one by one. Disable for better performance.'\noverlappingWavesTooltip     = 'Enable/Disable display of waves ending on the same swing point.'\nmaximumWavesTooltip         = 'Maximum number of waves to display.'\nbasicTargetsTooltip         = 'Enable/Disable horizontal price target lines. Disable for better performance.'\nextendedTargetsTooltip      = 'Enable/Disable extended price target horizontal lines. Disable for better performance.'\n\nshowPivotMarksInput         = input.bool(   true,   'Show Swing Highs & Lows',  group = '',             tooltip = showPivotMarksTooltip)\npivotLengthInput            = input.int(    10,     'Swing Length',             group = '',             tooltip = pivotLengthTooltip,   minval = 1)\n\nshowIchimokuLinesInput      = input.bool(   true,   'Show Lines',               group = ICHIMOKU_GROUP, tooltip = showIchimokuLinesTooltip)\nshowIchimokuKumoInput       = input.bool(   true,   'Show Kumo',                group = ICHIMOKU_GROUP, tooltip = showIchimokuKumoTooltip)\ntenkanSenLengthInput        = input.int(    9,      'Tenkan Sen Length',        group = ICHIMOKU_GROUP, tooltip = tenkanSenLengthTooltip)\nkinjuSenLengthInput         = input.int(    26,     'Kinjun Sen Length',        group = ICHIMOKU_GROUP, tooltip = kinjuSenLengthTooltip)\nsenkouSpanBLengthInput      = input.int(    52,     'Senkou Span B Length',     group = ICHIMOKU_GROUP, tooltip = senkouSpanBLengthTooltip)\nichimokuOffsetInput         = input.int(    26,     'Chikou & Senkou Offset',   group = ICHIMOKU_GROUP, tooltip = ichimokunOffsetTooltip)\n\nshowTimeForecastInput       = input.bool(   true,   'Show Time Cycle Forecast', group = TIME_GROUP,     tooltip = showTimeForecastTooltip)\ntimePatternInput            = input.string( KIHON,  'Forecast Pattern',         group = TIME_GROUP,     tooltip = timePatternTooltip,   options=[KIHON,TAITO])\ntimeForecastAnchorInput     = input.int(    1,      'Anchor forecast on last X time cycle', group = TIME_GROUP,    tooltip = timeForecastAnchorTooltip,minval = 1)\n\ntimeCycleModeInput          = input.string( SWINGS, 'Time Cycle Mode',          group = TIME_GROUP,     tooltip = timeCycleModeTooltip, options=[TENKAN,KIJUN,KUMO,HIGHS,LOWS,SWINGS,WAVE])\nwaveCyleInput               = input.string( WAVE_I, 'Wave Cycle',               group = TIME_GROUP,     tooltip = waveCyleTooltip,      options=[WAVE_I,WAVE_V,WAVE_N,WAVE_P,WAVE_Y,WAVE_W])\nshowTimeCyclesInput         = input.bool(   true,   'Show Time Cycles',         group = TIME_GROUP,     tooltip = showTimeCyclesTooltip)\nmaximumTimeCyclesInput      = input.int(    10,     'Show last X time cycles',  group = TIME_GROUP,     tooltip = maximumTimeCyclesTooltip, minval = 1)\n\nshowBasicWavesInput         = input.bool(   true,   'Basic Waves:'+EN_SPACE+EM_SPACE, group = WAVE_GROUP,   tooltip = '',               inline = 'basic waves')\nshowWaveIInput              = input.bool(   false,  'I',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'basic waves')\nwaveIColorInput             = input.color(#e91e63,FOUR_PER_EM_SPACE,          group = WAVE_GROUP,     tooltip = '',                   inline = 'basic waves') \nshowWaveVInput              = input.bool(   false,  'V',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'basic waves')\nwaveVColorInput             = input.color(color.yellow,'',                    group = WAVE_GROUP,     tooltip = '',                   inline = 'basic waves')\nshowWaveNInput              = input.bool(   true,   'N',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'basic waves')\nwaveNColorInput             = input.color(#5b9cf6,FOUR_PER_EM_SPACE,          group = WAVE_GROUP,     tooltip = basicWavesTooltip,    inline = 'basic waves')\n\nshowComplexWavesInput       = input.bool(   false,  'Complex Waves:',           group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nshowWavePInput              = input.bool(   true,   'P',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nwavePColorInput             = input.color(color.aqua,'',                      group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nshowWaveYInput              = input.bool(   true,   'Y',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nwaveYColorInput             = input.color(#ff5d00,SIX_PER_EM_SPACE,           group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nshowWaveWInput              = input.bool(   true,   'W',                        group = WAVE_GROUP,     tooltip = '',                   inline = 'complex waves')\nwaveWColorInput             = input.color(color.lime,HAIR_SPACE,              group = WAVE_GROUP,     tooltip = complexWavesTooltip,  inline = 'complex waves')\n\noverlappingWavesInput       = input.bool(   false,  'Overlapping Waves',        group = WAVE_GROUP,     tooltip = overlappingWavesTooltip)\nmaximumWavesInput           = input.int(    10,     'Show last X waves',        group = WAVE_GROUP,     tooltip = maximumWavesTooltip,    minval = 1)\n\nshowBasicTargetsInput       = input.bool(   true,   'Basic Targets:'+EM_SPACE+EM_SPACE, group = PRICE_GROUP,   tooltip = '',            inline = 'basic targets')\nshowTargetVInput            = input.bool(   true,   'V'+EM_SPACE+EN_SPACE,      group = PRICE_GROUP,    tooltip = '',                   inline = 'basic targets')\nshowTargetEInput            = input.bool(   true,   'E'+EM_SPACE,               group = PRICE_GROUP,    tooltip = '',                   inline = 'basic targets')\nshowTargetNInput            = input.bool(   true,   'N'+EM_SPACE,               group = PRICE_GROUP,    tooltip = '',                   inline = 'basic targets')\nshowTargetNTInput           = input.bool(   true,   'NT',                       group = PRICE_GROUP,    tooltip = basicTargetsTooltip,  inline = 'basic targets')\n\nshowExtendedTargetsInput    = input.bool(   false,  'Extended Targets:',        group = PRICE_GROUP,    tooltip = '',                   inline = 'extended targets')\nshowTarget2EInput           = input.bool(   true,   '2E'+EM_SPACE,              group = PRICE_GROUP,    tooltip = '',                   inline = 'extended targets')\nshowTarget3EInput           = input.bool(   true,   '3E',                       group = PRICE_GROUP,    tooltip = extendedTargetsTooltip,inline = 'extended targets')\n\n//---------------------------------------------------------------------------------------------------------------------}\n//DATA STRUCTURES & VARIABLES\n//---------------------------------------------------------------------------------------------------------------------{\n// @type                    Storage UDT for pivot points\n// @field barTime           Time index of the privot point     \n// @field barIndex          Bar index of the privot point\n// @field priceLevel        Price level of the pivot point\n// @field leg               Bullish or bearish bias (1 or 0)\ntype swingPoint\n    int barTime\n    int barIndex\n    float priceLevel\n    int leg\n\n// @type                    Storage UDT for time cycles\n// @field firstBarTime      Time index of the time cycle first bar \n// @field firstBarIndex     Bar index  of the time cycle first bar\n// @field lastBarTime       Time index of the time cycle last bar\n// @field lastBarIndex      Bar index  of the time cycle last bar\n// @field cycleLine         Plotted line\n// @field cycleLabel        Plotted label\ntype timeCycle\n    int firstBarTime\n    int firstBarIndex\n    int lastBarTime\n    int lastBarIndex\n    line cycleLine\n    label cycleLabel\n\n// @type                    Storage UDT for waves\n// @field points            chart.point array representing wave points\n// @field tag               tag representing the type of wave\n// @field bias              bullish of bearish bias as string\n// @field waveLabel         plotted label\n// @field line1             plotted line for P & Y waves \n// @field line2             plotted line for P & Y waves \ntype wave    \n    array<chart.point> points\n    string tag\n    string bias\n    label waveLabel\n    line line1\n    line line2\n\n// @type                    Storage UDT for price targets\n// @field targetLine        Plotted line\n// @field targetLabel       Plotted label\ntype priceTarget\n    line targetLine\n    label targetLabel\n\n// @variable                        storage array for `swingPoint` UDTs\nvar array<swingPoint> swingPoints   = array.new<swingPoint>()\n// @variable                        storage array for `timeCycle` UDTs\nvar array<timeCycle> timeCycles     = array.new<timeCycle>()\n// @variable                        storage array for time cycle forecast lines\nvar array<line> timeCyclesForecast  = array.new<line>()\n// @variable                        storage array for `wave` UDTs\nvar array<wave> waves               = array.new<wave>()\n// @variable                        storage array for `priceTarget` UDTs\nvar array<priceTarget> priceTargets = array.new<priceTarget>()\n\n// @variable                        current leg bullish or bearish bias (1 or 0)\nint currentLeg                      = na\n// @variable                        true if there is a new pivot `pivotLengthInput` bars ago\nbool newPivot                       = na\n// @variable                        true if there is a new pivot low `pivotLengthInput` bars ago\nbool pivotLow                       = na\n// @variable                        true if there is a new pivot high `pivotLengthInput` bars ago\nbool pivotHigh                      = na\n// @variable                        tenkan sen values for plotting and rest of calculations\nfloat tenkanSen                     = na\n// @variable                        kijun sen values for plotting and rest of calculations\nfloat kinjuSen                      = na\n// @variable                        chikou span is the close price plotted X bars in the past\nfloat chikouSpan                    = close\n// @variable                        senkou span A for plotting and rest of calculations\nfloat senkouSpanA                   = na\n// @variable                        senkou span B for plotting and rest of calculations\nfloat senkouSpanB                   = na\n// @variable                        tracks the change in senkou span A >= senkou span B\nbool kumoChange                     = na\n// @variable                        color changes depending on `kumoChange` variable\ncolor kumoColor                     = na\n// @variable                        true if close crosses tenkan sen\nbool tenkanSenCross                 = na\n// @variable                        true if close crosses kinjun sen\nbool kinjuSenCross                  = na\n// @variable                        highest high on last X bars + volatility measure\nfloat extremeHigh                   = na\n// @variable                        lower low on last X bars - volatility measure\nfloat extremeLow                    = na\n// @variable                        true if current bar is a new extreme high\nbool newExtremeHigh                 = na\n// @variable                        true if current bar is a new extreme low\nbool newExtremeLow                  = na\n// @variable                        lower low since the start of the time cycles - volatility measure\nvar float lowest                    = na\n// @variable                        bar index `pivotLengthInput` bars ago\nint legIndex                        = bar_index[pivotLengthInput]\n// @variable                        high `pivotLengthInput` bars ago\nfloat legHigh                       = high[pivotLengthInput]\n// @variable                        low `pivotLengthInput` bars ago\nfloat legLow                        = low[pivotLengthInput]\n// @variable                        time `pivotLengthInput` bars ago\nint legTime                         = time[pivotLengthInput]\n// @variable                        volatility measure to apply on `extremeHigh`, `extremeLow` and `lowest` calculations\nfloat atr200                        = ta.atr(200)\n\n//---------------------------------------------------------------------------------------------------------------------}\n//USER-DEFINED FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------{\n// @function            Get the value of the current leg, it can be 0 (bearish) or 1 (bullish)\n// @returns             int\nleg() =>\n    var leg     = 0\n    newLegHigh  = legHigh > ta.highest( pivotLengthInput)\n    newLegLow   = legLow  < ta.lowest(  pivotLengthInput)\n    \n    if newLegHigh\n        leg := BEARISH_LEG\n    else if newLegLow\n        leg := BULLISH_LEG\n    leg\n\n// @function            Identify whether the current value is the start of a new leg (swing)\n// @param leg           (int) Current leg value\n// @returns             bool\nstartOfNewLeg(int leg)      => ta.change(leg) != 0\n\n// @function            Identify whether the current level is the start of a new bearish leg (swing)\n// @param leg           (int) Current leg value\n// @returns             bool\nstartOfBearishLeg(int leg)  => ta.change(leg) == -1\n\n// @function            Identify whether the current level is the start of a new bullish leg (swing)\n// @param leg           (int) Current leg value\n// @returns             bool\nstartOfBullishLeg(int leg)  => ta.change(leg) == +1\n\n// @function            Average price on a price range\n// @param length        (int) Number of bar to calculate the price range\n// @returns             float\naverage(int length) => math.round_to_mintick( 0.5 * (ta.highest(length) + ta.lowest(length)))\n\n// @function            Calculate highest high and lowest low +/- atr(200) over the `lastXBars` period\n// @param lastXBars     (int) period for the calculations\n// @returns             float tuple\nextremesOnLastXBars(int lastXBars) => [ta.highest(lastXBars) + atr200, ta.lowest(lastXBars) - atr200]\n\n// @function            Parses swingPoint to chart.point\n// @param point         swingPoint to parse\n// @returns             chart.point ID\nchartPoint(swingPoint point) => chart.point.new(point.barTime, point.barIndex, point.priceLevel)\n\n// @function            I wave detector\n// @returns             wave ID\ngatherWaveI() =>    \n    size = array.size(swingPoints)\n\n    if size >= 2\n        A               = array.get(swingPoints, size - 2)\n        B               = array.get(swingPoints, size - 1)\n\n        waveSize        = B.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9\n\n        if minimumWaveSize\n            bias = B.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B)), WAVE_I, bias)\n\n// @function            V wave detector\n// @returns             wave ID\ngatherWaveV() =>     \n    size = array.size(swingPoints)\n\n    if size >= 3\n        A               = array.get(swingPoints, size - 3)\n        B               = array.get(swingPoints, size - 2)\n        C               = array.get(swingPoints, size - 1)\n\n        waveSize        = C.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9\n\n        threshold       = math.abs(A.priceLevel - B.priceLevel) * 0.2\n        isVWave         = C.priceLevel >= A.priceLevel - threshold and C.priceLevel <= A.priceLevel + threshold\n\n        if isVWave and minimumWaveSize\n            bias = C.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C)), WAVE_V, bias)\n\n// @function            N wave detector\n// @returns             wave ID\ngatherWaveN() =>     \n    size = array.size(swingPoints)\n\n    if size >= 4\n        A               = array.get(swingPoints, size - 4)\n        B               = array.get(swingPoints, size - 3)\n        C               = array.get(swingPoints, size - 2)\n        D               = array.get(swingPoints, size - 1)\n\n        waveSize        = D.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9    \n\n        threshold       = math.abs(A.priceLevel - B.priceLevel) * 0.2\n        isBullishWaveN  = A.priceLevel < B.priceLevel and C.priceLevel > A.priceLevel + threshold and C.priceLevel < B.priceLevel - threshold and D.priceLevel > B.priceLevel + threshold\n        isBearishWaveN  = A.priceLevel > B.priceLevel and C.priceLevel < A.priceLevel - threshold and C.priceLevel > B.priceLevel + threshold and D.priceLevel < B.priceLevel - threshold\n        \n        isWaveN         = isBullishWaveN or isBearishWaveN\n\n        if isWaveN and minimumWaveSize\n            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_N, bias)\n\n// @function            P wave detector\n// @returns             wave ID\ngatherWaveP() =>     \n    size = array.size(swingPoints)\n\n    if size >= 4\n        A               = array.get(swingPoints, size - 4)\n        B               = array.get(swingPoints, size - 3)\n        C               = array.get(swingPoints, size - 2)\n        D               = array.get(swingPoints, size - 1)\n\n        minimumDistance = math.min(math.abs(A.barIndex - C.barIndex), math.abs(B.barIndex - D.barIndex))\n        threshold       = 1.25 * minimumDistance\n        goodShape       = math.abs(A.barIndex - B.barIndex) <= threshold and math.abs(C.barIndex - D.barIndex) <= threshold\n\n        waveSize        = D.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9\n\n        isBullishWaveP  = math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == A.priceLevel and math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == B.priceLevel and C.priceLevel > D.priceLevel\n        isBearishWaveP  = math.min(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == A.priceLevel and math.max(A.priceLevel, B.priceLevel, C.priceLevel, D.priceLevel) == B.priceLevel and C.priceLevel < D.priceLevel\n\n        isWaveP         = isBullishWaveP or isBearishWaveP\n\n        if isWaveP and minimumWaveSize and goodShape\n            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_P, bias)\n    \n// @function            Y wave detector\n// @returns             wave ID\ngatherWaveY() =>     \n    size                = array.size(swingPoints)\n\n    if size >= 4\n        A               = array.get(swingPoints, size - 4)\n        B               = array.get(swingPoints, size - 3)\n        C               = array.get(swingPoints, size - 2)\n        D               = array.get(swingPoints, size - 1)\n\n        minimumDistance = math.min(math.abs(A.barIndex - C.barIndex), math.abs(B.barIndex - D.barIndex))\n        threshold       = 1.25 * minimumDistance\n        goodShape       = math.abs(A.barIndex - B.barIndex) <= threshold and math.abs(C.barIndex - D.barIndex) <= threshold\n\n        waveSize        = D.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9\n\n        isBullishWaveY  = math.max(A.priceLevel,B.priceLevel,C.priceLevel,D.priceLevel) == C.priceLevel and math.min(A.priceLevel,B.priceLevel,C.priceLevel,D.priceLevel) == D.priceLevel and A.priceLevel > B.priceLevel\n        isBearishWaveY  = math.min(A.priceLevel,B.priceLevel,C.priceLevel,D.priceLevel) == C.priceLevel and math.max(A.priceLevel,B.priceLevel,C.priceLevel,D.priceLevel) == D.priceLevel and A.priceLevel < B.priceLevel\n\n        isWaveY         = isBullishWaveY or isBearishWaveY\n\n        if isWaveY and minimumWaveSize and goodShape\n            bias = D.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D)), WAVE_Y, bias)\n       \n// @function            W wave detector\n// @returns             wave ID\ngatherWaveW() => \n    size = array.size(swingPoints)\n\n    if size >= 5\n        A               = array.get(swingPoints, size - 5)\n        B               = array.get(swingPoints, size - 4)\n        C               = array.get(swingPoints, size - 3)\n        D               = array.get(swingPoints, size - 2)\n        E               = array.get(swingPoints, size - 1)\n\n        waveSize        = E.barIndex - A.barIndex\n        minimumWaveSize = waveSize >= 9\n\n        threshold       = math.abs(A.priceLevel - B.priceLevel) * 0.2\n        isBullishWaveW  = C.priceLevel <= A.priceLevel - threshold and C.priceLevel >= B.priceLevel + threshold and E.priceLevel >= A.priceLevel - threshold and E.priceLevel <= A.priceLevel + threshold and D.priceLevel >= B.priceLevel - threshold and D.priceLevel <= B.priceLevel + threshold\n        isBearishWaveW  = C.priceLevel >= A.priceLevel + threshold and C.priceLevel <= B.priceLevel - threshold and E.priceLevel >= B.priceLevel - threshold and E.priceLevel <= B.priceLevel + threshold and D.priceLevel >= A.priceLevel - threshold and D.priceLevel <= A.priceLevel + threshold\n\n        isWaveW         = isBullishWaveW or isBearishWaveW\n\n        if isWaveW and minimumWaveSize\n            bias = E.leg == BULLISH_LEG ? BEARISH : BULLISH\n            wave.new(array.from(chartPoint(A), chartPoint(B), chartPoint(C), chartPoint(D), chartPoint(E)), WAVE_W, bias)\n\n// @function            Storage a new wave\n// @param newWave       wave to store\n// @returns             void\naddWave(wave newWave) =>\n    if waves.size() >= maximumWavesInput\n        w_ave = waves.shift()\n        label.delete(   w_ave.waveLabel)\n        line.delete(    w_ave.line1)\n        line.delete(    w_ave.line2)    \n    array.push(waves,newWave)\n\n// @function            Detects and stores new waves\n// @returns             void\ngatherWaves() =>\n    wave waveI = na\n    wave waveV = na\n    wave waveN = na\n    wave waveP = na\n    wave waveY = na\n    wave waveW = na\n\n    if showBasicWavesInput and showWaveIInput\n        waveI := gatherWaveI()\n    if showBasicWavesInput and showWaveVInput\n        waveV := gatherWaveV()\n    if showBasicWavesInput and showWaveNInput\n        waveN := gatherWaveN()\n    if showComplexWavesInput and showWavePInput\n        waveP := gatherWaveP()\n    if showComplexWavesInput and showWaveYInput\n        waveY := gatherWaveY()\n    if showComplexWavesInput and showWaveWInput\n        waveW := gatherWaveW()\n\n    if overlappingWavesInput\n        if not na(waveI)\n            addWave(waveI)\n        if not na(waveV)\n            addWave(waveV)\n        if not na(waveN)\n            addWave(waveN)\n        if not na(waveP)\n            addWave(waveP)\n        if not na(waveY)\n            addWave(waveY)\n        if not na(waveW)\n            addWave(waveW)\n    else\n        wave w_ave = na\n        if not na(waveN)\n            w_ave := waveN\n        else if not na(waveW)\n            w_ave := waveW\n        else if not na(waveP)\n            w_ave := waveP\n        else if not na(waveY)\n            w_ave := waveY\n        else if not na(waveV)\n            w_ave := waveV\n        else if not na(waveI)\n            w_ave := waveI\n\n        if not na(w_ave)        \n            addWave(w_ave)      \n\n// @function            Helper function to choose the right wave color\n// @param typeOfWave    (string) type of wave\n// @returns             color\ncolorSelection(string typeOfWave) =>\n    switch typeOfWave\n        WAVE_I => waveIColorInput\n        WAVE_V => waveVColorInput\n        WAVE_N => waveNColorInput\n        WAVE_P => wavePColorInput\n        WAVE_Y => waveYColorInput\n        WAVE_W => waveWColorInput\n\n// @function            Draws stored waves\n// @returns             void\nplotWaves() =>\n    for eachPolyline in polyline.all\n        polyline.delete(eachPolyline)\n    \n    for [index,eachWave] in waves        \n        label.delete(eachWave.waveLabel)\n\n        // we draw P & Y waves with 2 lines\n        if eachWave.tag == WAVE_P or eachWave.tag == WAVE_Y\n            eachWave.line1.delete()\n            eachWave.line2.delete()\n            eachWave.line1 := line.new(eachWave.points.get(0), eachWave.points.get(2), xloc.bar_time, color = colorSelection(eachWave.tag), style = line.style_solid, width = 2)\n            eachWave.line2 := line.new(eachWave.points.get(1), eachWave.points.get(3), xloc.bar_time, color = colorSelection(eachWave.tag), style = line.style_solid, width = 2)\n        else\n            // we draw the rest of waves with polyline\n            polyline.new(eachWave.points, false, false, xloc.bar_time, colorSelection(eachWave.tag), line_style = line.style_solid, line_width = 2)            \n\n        overlappingLabel    = index > 0 ? eachWave.points.last().time == waves.get(index - 1).points.last().time : false\n        style               = eachWave.bias == BULLISH ? label.style_label_down : label.style_label_up\n\n        if overlappingLabel\n            eachWave.waveLabel := waves.get(index - 1).waveLabel\n            eachWave.waveLabel.set_text(eachWave.waveLabel.get_text() + '\\n' + eachWave.tag)\n            eachWave.waveLabel.set_textcolor(colorSelection(eachWave.tag))\n        else\n            eachWave.waveLabel := label.new(eachWave.points.last(),eachWave.tag,xloc.bar_time,color=color(na),style=style,textcolor= colorSelection(eachWave.tag))\n            label.delete(na)    \n\n// @function            Draws a price target with a line and a label\n// @param barIndex      (int) starting bar index for line\n// @param priceLevel    (float) price level for line and label\n// @param tag           (string) text to display in label\n// @returns             void\ndrawPriceTarget(int barIndex, float priceLevel, string tag) =>\n    array.push(priceTargets,priceTarget.new(\n         line.new(barIndex, priceLevel, last_bar_index + ichimokuOffsetInput, priceLevel, color = chart.fg_color, style = line.style_dotted),\n         label.new(last_bar_index + ichimokuOffsetInput, priceLevel,tag + ' (' + str.tostring(priceLevel) + ')', color=color(na), textcolor=chart.fg_color, style= label.style_label_left)))\n\n// @function            Detects developing N waves and draws price targets\n// @returns             void\npriceTheoryTargets() =>\n    size = array.size(swingPoints)\n\n    if size >= 3\n        A                           = array.get(swingPoints, size - 3)\n        B                           = array.get(swingPoints, size - 2)\n        C                           = array.get(swingPoints, size - 1)\n\n        waveSize                    = C.barIndex - A.barIndex\n        minimumWaveSize             = waveSize >= 9    \n\n        threshold                   = math.abs(A.priceLevel - B.priceLevel) * 0.2\n        isDevelopingBullishWaveN    = A.priceLevel < B.priceLevel and C.priceLevel > A.priceLevel + threshold and C.priceLevel < B.priceLevel - threshold\n        isDevelopingBearishWaveN    = A.priceLevel > B.priceLevel and C.priceLevel < A.priceLevel - threshold and C.priceLevel > B.priceLevel + threshold\n        \n        isDevelopingWaveN           = isDevelopingBullishWaveN or isDevelopingBearishWaveN               \n\n        calculationV                = .0\n        calculationE                = .0\n        calculationN                = .0\n        calculationNT               = .0\n        calculation2E               = .0\n        calculation3E               = .0\n\n        if isDevelopingWaveN and minimumWaveSize\n\n            for eachPriceTarget in priceTargets\n                line.delete(eachPriceTarget.targetLine)\n                label.delete(eachPriceTarget.targetLabel) \n            array.clear(priceTargets)                   \n\n            if isDevelopingBullishWaveN\n                calculationV    := B.priceLevel + (     B.priceLevel - C.priceLevel)\n                calculationE    := B.priceLevel + (     B.priceLevel - A.priceLevel)\n                calculationN    := C.priceLevel + (     B.priceLevel - A.priceLevel)\n                calculationNT   := C.priceLevel + (     C.priceLevel - A.priceLevel)\n                calculation2E   := B.priceLevel + 2*(   B.priceLevel - A.priceLevel)\n                calculation3E   := B.priceLevel + 3*(   B.priceLevel - A.priceLevel)\n\n            if isDevelopingBearishWaveN\n                calculationV    := B.priceLevel - (     C.priceLevel - B.priceLevel)\n                calculationE    := B.priceLevel - (     A.priceLevel - B.priceLevel)\n                calculationN    := C.priceLevel - (     A.priceLevel - B.priceLevel)\n                calculationNT   := C.priceLevel - (     A.priceLevel - C.priceLevel)\n                calculation2E   := B.priceLevel - 2*(   A.priceLevel - B.priceLevel)\n                calculation3E   := B.priceLevel - 3*(   A.priceLevel - B.priceLevel)\n\n            if showBasicTargetsInput and showTargetVInput\n                drawPriceTarget(C.barIndex, calculationV,'V')\n            if showBasicTargetsInput and showTargetEInput                               \n                drawPriceTarget(C.barIndex, calculationE,'E')\n            if showBasicTargetsInput and showTargetNInput\n                drawPriceTarget(C.barIndex, calculationN,'N')\n            if showBasicTargetsInput and showTargetNTInput\n                drawPriceTarget(C.barIndex, calculationNT,'NT')\n            if showExtendedTargetsInput and showTarget2EInput\n                drawPriceTarget(C.barIndex, calculation2E,'2E')\n            if showExtendedTargetsInput and showTarget3EInput\n                drawPriceTarget(C.barIndex, calculation3E,'3E')\n\n// @function            Update each price target line and label to draw always with an `ichimokuOffsetInput` offset\n// @returns             void\nupdatePriceTargets() =>\n    for eachPriceTarget in priceTargets\n        line.set_x2(eachPriceTarget.targetLine,     last_bar_index + ichimokuOffsetInput)\n        label.set_x(eachPriceTarget.targetLabel,    last_bar_index + ichimokuOffsetInput)\n\n// @function            Helper function to update last time cycle values before store the new one\n// @param cycle         (timeCycle) new detected cycle\n// @returns             int\nupdateLastTimeCycle(timeCycle cycle) =>\n    size = array.size(timeCycles)\n    if size > 0\n        c_ycle              = array.last(timeCycles)\n        c_ycle.lastBarIndex := cycle.firstBarIndex\n        c_ycle.lastBarTime  := cycle.firstBarTime\n\n// @function            Helper function to store a new time cycle\n// @param cycle         (timeCycle) time cycle to store\n// @returns             void\naddTimeCycle(timeCycle cycle) =>\n    updateLastTimeCycle(cycle)\n    size = array.size(timeCycles)\n\n    if size >= (maximumTimeCyclesInput + 1)\n        c_ycle = array.shift(timeCycles)\n        line.delete(    c_ycle.cycleLine)            \n        label.delete(   c_ycle.cycleLabel)\n    array.push(timeCycles, cycle)\n\n// @function            Helper function to parse `wave` to `timeCycle`\n// @returns             void\nparseWavesToTimeCycles() =>    \n    for eachCycle in timeCycles\n        eachCycle.cycleLabel.delete()\n        eachCycle.cycleLine.delete()\n    timeCycles.clear()\n\n    for index = waves.size() - 1 to 0\n        if timeCycles.size() >= maximumTimeCyclesInput\n            break\n        if waves.get(index).tag == waveCyleInput\n            timeCycles.unshift(timeCycle.new(waves.get(index).points.first().time, waves.get(index).points.first().index, waves.get(index).points.last().time, waves.get(index).points.last().index))\n\n// @function            Detect and store time cycles\n// @returns             void\ngatherTimeCycles() => \n    timeCycle newCycle = switch timeCycleModeInput\n        HIGHS   => pivotHigh        ? timeCycle.new(legTime,legIndex)   : na \n        LOWS    => pivotLow         ? timeCycle.new(legTime,legIndex)   : na\n        SWINGS  => newPivot         ? timeCycle.new(legTime,legIndex)   : na\n        TENKAN  => tenkanSenCross   ? timeCycle.new(time,bar_index)     : na\n        KIJUN   => kinjuSenCross    ? timeCycle.new(time,bar_index)     : na\n        KUMO    => kumoChange       ? timeCycle.new(time,bar_index)     : na\n        WAVE    => na\n\n    if not na(newCycle)\n        addTimeCycle(newCycle)\n    else if timeCycleModeInput == WAVE and waves.size() > 0\n        parseWavesToTimeCycles()\n\n// @function            Draws each time cycle with a line and a label\n// @returns             last label ID\nplotTimeCycles() =>\n    size = array.size(timeCycles)\n\n    if size > 1\n        priceLevel = lowest\n        \n        for [index,eachCycle] in timeCycles             \n            line.delete(eachCycle.cycleLine)            \n            label.delete(eachCycle.cycleLabel)       \n\n            tagPosition = math.max(1,math.round(0.5*(eachCycle.lastBarTime - eachCycle.firstBarTime)))\n            \n            if index == array.size(timeCycles) - 1 and timeCycleModeInput != WAVE\n                break\n\n            if timeCycleModeInput == WAVE and index > 0\n                if eachCycle.firstBarIndex < timeCycles.get(index-1).lastBarIndex\n                    priceLevel -= atr200\n\n            eachCycle.cycleLine := line.new(eachCycle.firstBarTime,priceLevel,eachCycle.lastBarTime,priceLevel,xloc.bar_time,color=chart.fg_color,style=line.style_arrow_right)\n            eachCycle.cycleLabel := label.new(eachCycle.firstBarTime + tagPosition,priceLevel,str.tostring(eachCycle.lastBarIndex - eachCycle.firstBarIndex),xloc.bar_time,color=color(na),style=label.style_none,textcolor=chart.fg_color)\n            \n// @function            Draws time cycle forecast vertical lines\n// @returns             void\nplotTimeCyclesForecast() =>\n    lastArrayIndex = array.size(timeCycles) - (timeCycleModeInput == WAVE ? 0 : 1)\n\n    if lastArrayIndex >= timeForecastAnchorInput\n        cycle               = array.get(timeCycles,lastArrayIndex - timeForecastAnchorInput)\n        taitoCycle          = cycle.lastBarIndex - cycle.firstBarIndex\n        forecastAnchor      = cycle.lastBarIndex\n        array<int> indexes  = switch timePatternInput\n            KIHON => array.from(9, 17, 26, 33, 42, 51, 65, 76, 129, 172, 200, 257)\n            TAITO => array.from(taitoCycle, 2*taitoCycle, 3*taitoCycle, 4*taitoCycle, 5*taitoCycle, 6*taitoCycle, 7*taitoCycle, 8*taitoCycle, 9*taitoCycle)\n        \n        for eachLine in timeCyclesForecast\n            line.delete(eachLine)\n        array.clear(timeCyclesForecast)\n\n        array.push(timeCyclesForecast, line.new(forecastAnchor, extremeHigh, forecastAnchor, extremeLow, color=chart.fg_color, style=line.style_solid))\n\n        for index in indexes\n\n            if (forecastAnchor + index) > (last_bar_index + 500)\n                break\n            array.push(timeCyclesForecast,line.new(forecastAnchor + index,extremeHigh,forecastAnchor + index,extremeLow,color=chart.fg_color,style=line.style_dotted))\n\n// @function            Update each time cycle forecast line extremes\n// @returns             void\nupdateTimeCyclesForecast() =>\n    if newExtremeHigh or newExtremeLow\n        for eachTimeCycle in timeCyclesForecast\n            if newExtremeHigh\n                eachTimeCycle.set_y1(extremeHigh)\n            if newExtremeLow\n                eachTimeCycle.set_y2(extremeLow)\n       \n//---------------------------------------------------------------------------------------------------------------------}\n//MUTABLE VARIABLES & EXECUTION\n//---------------------------------------------------------------------------------------------------------------------{\ncurrentLeg                  := leg()\nnewPivot                    := startOfNewLeg(currentLeg)\npivotLow                    := startOfBullishLeg(currentLeg)\npivotHigh                   := startOfBearishLeg(currentLeg)\n\ntenkanSen                   := average(tenkanSenLengthInput)\nkinjuSen                    := average(kinjuSenLengthInput)\nsenkouSpanA                 := 0.5*(tenkanSen + kinjuSen)\nsenkouSpanB                 := average(senkouSpanBLengthInput)\nkumoChange                  := ta.change(senkouSpanA >= senkouSpanB)\nkumoColor                   := senkouSpanA >= senkouSpanB ? color.new(GREEN,80) : color.new(RED,80)\n\ntenkanSenCross              := ta.cross(close,tenkanSen)\nkinjuSenCross               := ta.cross(close,kinjuSen)\n\n[e_xtremeHigh,e_xtremeLow]  = extremesOnLastXBars(200)\nextremeHigh                 := e_xtremeHigh\nextremeLow                  := e_xtremeLow\nnewExtremeHigh              := ta.change(extremeHigh)   != 0\nnewExtremeLow               := ta.change(extremeLow)    != 0    \n\nif array.size(timeCycles) > 0 and bar_index > 200\n    lowest := ta.lowest(bar_index - array.first(timeCycles).firstBarIndex) - atr200\n\n// @variable            true if current candle is a new time cycle\nbool newTimeCycle = switch timeCycleModeInput\n    HIGHS   => pivotHigh\n    LOWS    => pivotLow\n    SWINGS  => newPivot\n    TENKAN  => tenkanSenCross\n    KIJUN   => kinjuSenCross\n    KUMO    => kumoChange\n    WAVE    => newPivot\n\n// we execute the logic only once per bar close\nif barstate.isconfirmed    \n    // if there is a new swing point execute the logic\n    if newPivot\n        priceLevel      = legHigh\n        legBias         = BEARISH_LEG\n\n        // if the new swing point is a pivot low change the values\n        if pivotLow\n            priceLevel  := legLow\n            legBias     := BULLISH_LEG\n\n        // we store the new swing point\n        array.push(swingPoints,swingPoint.new(legTime,legIndex,priceLevel,legBias))        \n\n        // we gather new waves\n        gatherWaves()\n\n        if showBasicWavesInput or showComplexWavesInput\n            // we plot all stored waves\n            plotWaves()\n        \n        if showBasicTargetsInput or showExtendedTargetsInput\n            // we detect and plot price targets\n            priceTheoryTargets()\n\n    if priceTargets.size() > 0\n        // if there are price targets, we update them\n        updatePriceTargets()    \n\n    if newTimeCycle\n        // at each new time cycle we detect and store the new cycle\n        gatherTimeCycles()\n\n        if showTimeCyclesInput\n            // we plot all time cycles\n            plotTimeCycles()            \n\n        if showTimeForecastInput      \n            // we plot all time cycles forecast\n            plotTimeCyclesForecast()\n            \n    else\n        if showTimeForecastInput\n            // we update time cycles forecast vertical lines\n            updateTimeCyclesForecast()\n\n// plotting circle marks on swing highs and lows\nplotshape(      showPivotMarksInput     ? pivotLow      : na, 'Swing High', shape.circle, location.belowbar, GREEN, -pivotLengthInput)\nplotshape(      showPivotMarksInput     ? pivotHigh     : na, 'Swing Low',  shape.circle, location.abovebar, RED,   -pivotLengthInput)\n\n// plotting basic Ichimoku lines and kumo\nplot(           showIchimokuLinesInput  ? tenkanSen     : na, 'TenkanSen',  color = RED)\nplot(           showIchimokuLinesInput  ? kinjuSen      : na, 'KinjuSen',   color =color.blue)\nplot(           showIchimokuLinesInput  ? chikouSpan    : na, 'ChikouSpan', offset = -ichimokuOffsetInput, color = color.new(#787b86, 50))\n\nkumoFast = plot(showIchimokuKumoInput   ? senkouSpanA   : na, 'SenkouSpanA', kumoColor, offset = ichimokuOffsetInput)\nkumoSlow = plot(showIchimokuKumoInput   ? senkouSpanB   : na, 'SenkouSpanB', kumoColor, offset = ichimokuOffsetInput)\n\nfill(kumoFast, kumoSlow, color = kumoColor, title='Kumo')\n\n//---------------------------------------------------------------------------------------------------------------------}        ","updated":"2024-05-16T13:41:45.224932Z","version":"1.0"}