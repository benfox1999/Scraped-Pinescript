{"created":"2023-11-07T17:34:15.752666Z","extra":{"kind":"study","sourceInputsCount":2},"lastVersionMaj":"1.0","scriptAccess":"open_no_auth","scriptName":"Intersection Value Functions","source":"_                                                                                                                                                                                                        = '\n \"Pinefest #1 October 21-28, 2023\"\n  ----------------------------------------------------------------------------------------------------------------------------------------- \n | █ CHALLENGE                                                                                                                             |\n |                                                                                                                                         |\n |   Create three functions that will return the exact value where two data series intersect:                                              |\n |                                                                                                                                         |\n |   • crossValue     (source1, source2)                                                                                                   | \n |   • crossoverValue (source1, source2)                                                                                                   | \n |   • crossunderValue(source1, source2)                                                                                                   |\n |                                                                                                                                         |\n |   When a cross occurs, the functions must return the intersection`s value. When no cross occurs, they must return na.                   |\n |                                                                                                                                         |\n  -----------------------------------------------------------------------------------------------------------------------------------------                                                                '\n\n//@version=5\nindicator(  title = 'Intersection Value Functions'\n     , max_boxes_count  = 500\n     , max_lines_count  = 500\n     , max_labels_count = 500\n     , overlay          = true\n     )\n\n//---------------------------------------------------------------------------------------------------------------------}\n//Challenge Functions\n//---------------------------------------------------------------------------------------------------------------------{\n// getSlopes()\n//\n//@function Get the slope of the lines connecting source1/source2 to source1[1]/source2[1]\n//@param    source1 (float) source value 1\n//@param    source2 (float) source value 2 \n//@returns  Slopes of the lines\ngetSlopes(float source1, float source2) =>\n\n    //Get slopes\n    m1  =  ta.change(source1) \n    m2  =  ta.change(source2)\n\n    //Output\n    [m1 , m2]\n\n// commonScalingFactor()\n//\n//@function Common scaling factor of the lines connecting source1/source2 to source1[1]/source2[1]\n//@param    source1 (float) source value 1 \n//@param    source2 (float) source value 2\n//@param    m1      (float) slope of the line originating from source1 \n//@param    m2      (float) slope of the line originating from source2 \n//@returns  Common scaling factor\ncommonScalingFactor(float source1, float source2, float m1, float m2) => \n    \n    //Output\n    (source1 - source2) / (m1 - m2) \n\n// crossValue()\n//\n//@function Finds intersection value of 2 lines/values if any cross occurs - First function of challenge -> crossValue(source1, source2)\n//@param    source1 (float) source value 1 \n//@param    source2 (float) source value 2\n//@returns  Intersection value\nmethod crossValue(float source1, float source2)=>\n    float insct = na\n\n    //Slope calculations, called on each bar\n    [m1, m2] = getSlopes(source1, source2)\n\n    //Test for cross\n    if ta.cross(source1, source2)\n\n        //Find common scaling factor\n        sf = commonScalingFactor(source1, source2, m1, m2)\n    \n        //Find intersection value\n        insct := source1 - sf * m1\n\n// crossoverValue()\n//\n//@function Finds intersection value of 2 lines/values if crossover occurs - Second function of challenge -> crossoverValue(source1, source2) \n//@param    source1 (float) source value 1 \n//@param    source2 (float) source value 2\n//@returns  Intersection value\nmethod crossoverValue(float source1, float source2)=>\n    float insct = na\n\n    //Slope calculations, called on each bar\n    [m1, m2] = getSlopes(source1, source2)\n\n    //Test for cross\n    if ta.crossover(source1, source2)\n\n        //Find common scaling factor\n        sf = commonScalingFactor(source1, source2, m1, m2)\n    \n        //Find intersection value\n        insct := source1 - sf * m1\n\n// crossunderValue()\n//\n//@function Finds intersect of 2 lines/values if crossunder occurs - Third function of challenge -> crossunderValue(source1, source2) \n//@param    source1 (float) source value 1 \n//@param    source2 (float) source value 2\n//@returns  Intersection value\nmethod crossunderValue(float source1, float source2) =>\n    float insct = na\n\n    //Slope calculations, called on each bar\n    [m1, m2] = getSlopes(source1, source2)\n\n    //Test for cross\n    if ta.crossunder(source1, source2)\n\n        //Find common scaling factor\n        sf = commonScalingFactor(source1, source2, m1, m2)\n    \n        //Find intersection value\n        insct := source1 - sf * m1\n\n//---------------------------------------------------------------------------------------------------------------------}\n//Usage - Code used to highlight the proposed functions usage.\n//---------------------------------------------------------------------------------------------------------------------{\n//Settings\n//-----------------------------------------------------------------------------{\n//Sources selection\nsourceA = input.string('SMA', 'Source A'\n  , options = ['SMA', 'EMA', 'WMA', 'Hull', 'External A']\n  , inline  = 'sourceA')\n\nlenA    = input.int(9, '', minval = 1\n  , inline = 'sourceA')\n\nexternalA = input.source(close, 'External A')\n\nsourceB = input.string('SMA', 'Source B'\n  , options = ['SMA', 'EMA', 'WMA', 'Hull', 'External B']\n  , inline  = 'sourceB')\n\nlenB    = input.int(20, '', minval = 1\n  , inline = 'sourceB')\n\nexternalB = input.source(open, 'External B')\n\n//Style\ncoCss = input.color(#2962ff, 'Crossover'\n  , inline = 'crossover')\n\ncoAreaCss = input.color(color.new(#2962ff, 90), ''\n  , inline = 'crossover')\n\ncuCss = input.color(#ff5d00, 'Crossover'\n  , inline = 'crossunder')\n\ncuAreaCss = input.color(color.new(#ff5d00, 90), ''\n  , inline = 'crossunder')\n\nextend = input(true, 'Extend Intersections')\n\n//SMA Intersection Matrix\nshowDash  = input(true, 'Show Matrix'\n  , group = 'SMA Intersection Matrix')\n\nminLen = input.int(10, 'SMA Length Range'\n  , minval = 1\n  , inline = 'lenrange'\n  , group = 'SMA Intersection Matrix')\n\nmaxLen = input.int(20, ''\n  , minval = 1\n  , inline = 'lenrange'\n  , group = 'SMA Intersection Matrix')\n\ndashLoc  = input.string('Top Right', 'Location'\n  , options = ['Top Right', 'Bottom Right', 'Bottom Left']\n  , group = 'SMA Intersection Matrix')\n\ntextSize = input.string('Small', 'Size'\n  , options = ['Tiny', 'Small', 'Normal']\n  , group = 'SMA Intersection Matrix')\n\n//Magnifying Glass\nmagnify = input(true, 'Magnify'\n  , group = 'Magnifying Glass')\n\nresolution = input.int(20, 'Resolution'\n  , minval = 2\n  , group = 'Magnifying Glass')\n\noffset = input.int(10, 'Offset'\n  , minval = 2\n  , group = 'Magnifying Glass')\n\n//----------------------------------------------------------------------------}\n//Methods/Functions\n//----------------------------------------------------------------------------{\n//@function Return various supported moving averages outputs based on an input string\n//@param    id       (string) determine the function output, supported strings include ['SMA', 'EMA', 'WMA', 'Hull'], else an external value is returned\n//@param    len      (simple int) moving average length if applicable\n//@param    external (float) external source\n//@returns  Chosen moving average output or \"external\" if \"id\" is not part of supported options \nmethod source(string id, simple int len, float external) =>\n    sma = ta.sma(close, len)\n    ema = ta.ema(close, len)\n    wma = ta.wma(close, len)\n    hma = ta.hma(close, len)\n\n    output = switch id\n        'SMA'  => sma\n        'EMA'  => ema\n        'WMA'  => wma\n        'Hull' => hma\n        => external\n\n//@function Return the N * N intersection matrix from an array of values with size N and the values in its previous instance\n//@param    array_series (array<float>) array of values, requires an array supporting historical referencing\n//@returns  (matrix<float>) Intersection matrix showing intersection value between all array entries\nintersectionMatrix(array_series)=>\n    N = array_series.size()-1\n    ismt = matrix.new<float>(N+1, N+1)\n    sfmt = matrix.new<float>(N+1, N+1)\n    \n    prev_array = array_series[1]\n\n    if not na(prev_array)\n        //Columns\n        for i = 0 to N\n            //Get source1 and previous source1 value\n            source1 = array_series.get(i)\n            prev1 = prev_array.get(i)\n\n            //source1 slope\n            m1 = source1 - prev1\n\n            //Rows\n            for j = i to N\n                //Na is column index = row index\n                if i == j\n                    ismt.set(j, i, float(na))\n                else\n                    //Get source2 and previous source2 value\n                    source2 = array_series.get(j)\n                    prev2 = prev_array.get(j)\n\n                    //source2 slope\n                    m2 = source2 - prev2\n                    \n                    //Test for cross\n                    if (source1 - source2) * (prev1 - prev2) < 0\n                        //Find common scaling factor\n                        sf = commonScalingFactor(source1, source2, m1, m2)\n\n                        //Find intersection value\n                        insct = source1 - sf * m1\n                        \n                        //Set matrix intersection and scaling factor values\n                        ismt.set(i, j, insct)\n                        sfmt.set(i, j, 1 - sf)\n\n    //Output\n    [ismt, sfmt]\n\n//@function Draw graphical elements on the chart highlighting crossing events and intersection value/area\n//@param    intersection_val (float) Intersection value between source1 and source2\n//@param    scaling_factor   (float) Common scaling factor between two crossing lines\n//@param    max              (float) area top\n//@param    min              (float) area bottom\n//@param    crossover        (bool)  true if the lines are crossing over each other\n//@param    css              (color) color of the line/label text\n//@param    css_area         (color) color of the box area\n//@returns  [line, label, box] drawing elements \ndraw(intersection_val, scaling_factor, max, min, crossover, css, css_area)=>\n    n = bar_index\n\n    //Intersection level\n    lvl = line.new(\n      chart.point.from_index(n-1, intersection_val)\n      , chart.point.from_index(n, intersection_val)\n      , color = css)\n\n    //Intersection value label and display 1 - scaling factor when hovering over label\n    lbl = label.new(\n      chart.point.from_index(n, crossover ? min : max)\n      , color = color(na)\n      , textcolor = css\n      , text = str.tostring(math.round_to_mintick(intersection_val))\n      , style = crossover ? label.style_label_up : label.style_label_down\n      , size = size.small\n      , tooltip = str.tostring(1 - scaling_factor, '#.##'))\n    \n    //Highlight intersection area\n    bx = box.new(\n      chart.point.from_index(n-1, max)\n      , chart.point.from_index(n, min)\n      , na\n      , bgcolor = css_area)\n\n    [lvl, lbl, bx]\n\n//@function Display an higher resolution representation of intersecting lines\n//@param    source1      (float) source value 1\n//@param    source2      (float) source value 2\n//@param    css1         (color) color of source 1 line\n//@param    css2         (color) color of source 2 line\n//@param    intersec_css (color) color of intersection line\n//@param    area_css     (color) color of box area\nzoomIn(source1, source2, css1, css2, intersec_css, area_css)=>\n    var source1_l  = line.new(na, na, na, na, color = css1) \n    var source2_l  = line.new(na, na, na, na, color = css2)\n    var intersec_l = line.new(na, na, na, na)\n    var cross_area = box.new(na, na, na, na, chart.fg_color) \n    \n    n = bar_index\n\n    //Find intersection value on crosses\n    intersection_val = source1.crossValue(source2)\n\n    //Draw new elements on crossing event\n    if not na(intersection_val)\n        //Get common scaling factor\n        sf = commonScalingFactor(source1, source2, source1 - source1[1], source2 - source2[1])\n        \n        //Slopes run\n        dx1 = int(resolution * (1 - sf))\n        dx2 = int(resolution * sf)\n\n        //Offset\n        start = int(resolution * (1 - sf)) + offset\n\n        //Coordinates\n        l1y1 = source1 - (source1 - source1[1]) * dx1\n        l1y2 = source1 + (source1 - source1[1]) * dx2\n\n        l2y1 = source2 - (source2 - source2[1]) * dx1\n        l2y2 = source2 + (source2 - source2[1]) * dx2\n\n        //Set new lines coordinates\n        source1_l.set_xy1(n - dx1 + start, l1y1) \n        source1_l.set_xy2(n + dx2 + start, l1y2)\n\n        source2_l.set_xy1(n - dx1 + start, l2y1)\n        source2_l.set_xy2(n + dx2 + start, l2y2)\n\n        intersec_l.set_xy1(n - dx1 + start, intersection_val)\n        intersec_l.set_xy2(n + dx2 + start, intersection_val)\n        intersec_l.set_color(intersec_css)\n\n        //Area\n        cross_area.set_lefttop(n - dx1 + start, math.max(l1y1, l1y2, l2y1, l2y2))\n        cross_area.set_rightbottom(n + dx2 + start, math.min(l1y1, l1y2, l2y1, l2y2))\n        cross_area.set_bgcolor(area_css)\n    else\n        //Update coordinates\n        x1 = source1_l.get_x1()\n        x2 = source1_l.get_x2()\n\n        source1_l.set_x1(x1 + 1)   , source1_l.set_x2(x2 + 1)\n        source2_l.set_x1(x1 + 1)   , source2_l.set_x2(x2 + 1)\n        intersec_l.set_x1(x1 + 1)  , intersec_l.set_x2(x2 + 1)\n        cross_area.set_left(x1 + 1), cross_area.set_right(x2 + 1)\n\n//----------------------------------------------------------------------------}\n//Highlight crosses and intersection value\n//----------------------------------------------------------------------------{\n//Intersections drawing elements\nvar line  intersection_lvl = na \nvar label intersection_lbl = na \nvar box   intersection_box  = na\n\nn = bar_index\nsource1 = sourceA.source(lenA, externalA)\nsource2 = sourceB.source(lenB, externalB)\n\n//Find intersection value on crosses\nintersection_val = source1.crossValue(source2)\n\nvar l1 = line.new(na,na,na,na)\nvar l2 = line.new(na,na,na,na)\nvar l3 = line.new(na,na,na,na)\n\n//Highlight intersection information\nif not na(intersection_val)\n\n    //Get common scaling factor\n    sf = commonScalingFactor(source1, source2, source1 - source1[1], source2 - source2[1])\n    \n    //Draw elements\n    crossover = source1 > source2\n    max = math.max(source1, source2, source1[1], source2[1])\n    min = math.min(source1, source2, source1[1], source2[1])\n\n    [lvl_, lbl_, bx_] = draw(intersection_val, sf, max, min\n      , crossover\n      , crossover ? coCss : cuCss\n      , crossover ? coAreaCss : cuAreaCss)\n    \n    intersection_lvl := lvl_\n    intersection_lbl := lbl_\n    intersection_box := bx_\n\nelse\n    //Extend\n    if extend\n        intersection_lvl.set_x2(n)\n        intersection_lbl.set_x(int(math.avg(n, intersection_lvl.get_x1())))\n        intersection_box.set_right(n)\n\n//Zoom\nif magnify\n    zoomIn(source1, source2, #089981, #f23645\n      , source1 > source2 ? coCss : cuCss\n      , source1 > source2 ? coAreaCss : cuAreaCss)\n\n//-----------------------------------------------------------------------------}\n//Highlight SMA intersection matrix\n//-----------------------------------------------------------------------------{\nvar table_position = dashLoc == 'Bottom Left' ? position.bottom_left \n  : dashLoc == 'Top Right' ? position.top_right \n  : position.bottom_right\n\nvar table_size = textSize == 'Tiny' ? size.tiny \n  : textSize == 'Small' ? size.small \n  : size.normal\n\n//Declare array of sma values\nsma_array = array.new<float>(0)\n\ncsum = ta.cum(close)\n\n//Calculate SMA for periods from min_per to max_per\nfor i = minLen to maxLen\n    ma = (csum - csum[i]) / i\n    sma_array.push(ma)\n\n//Get matrices\n[ismt, sfmt] = intersectionMatrix(sma_array)\n\n//Set SMA intersection matrix\nif barstate.islast and showDash\n    cols = ismt.columns()\n    rows = ismt.rows()\n    \n    //Table\n    tb = table.new(table_position, cols+2, rows+2\n      , bgcolor = #1e222d\n      , border_color = #373a46\n      , border_width = 1\n      , frame_color = #373a46\n      , frame_width = 1)\n\n    for i = 0 to rows-1\n        //SMA periods\n        tb.cell(0, i+1, str.tostring(minLen + i)\n          , text_color = color.white\n          , text_size = table_size)\n\n        tb.cell(i+1, 0, str.tostring(minLen + i)\n          , text_color = color.white\n          , text_size = table_size)\n\n        for j = 0 to cols-1\n            //Set intersection value\n            if not na(ismt.get(i, j))\n                tb.cell(i+1, j+1, str.tostring(math.round_to_mintick(ismt.get(i, j)))\n                  , text_color = color.white\n                  , text_size = table_size\n                  , tooltip = str.tostring(sfmt.get(i, j), '#.##'))\n    \n    //Dashboard title\n    tb.cell(0, rows, 'SMA Intersection Matrix'\n      , text_color = color.white\n      , text_size = table_size)\n    tb.merge_cells(0, rows, cols, rows)\n\n//----------------------------------------------------------------------------}\n//Plots\n//----------------------------------------------------------------------------{\nplot(source1, 'Source A', #089981)\nplot(source2, 'Source B', #f23645)\n\n//----------------------------------------------------------------------------}\n//---------------------------------------------------------------------------------------------------------------------}","updated":"2023-11-07T17:34:15.752666Z","version":"1.0"}