{"created":"2024-03-05T11:55:11.732076Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"2.0","scriptAccess":"open_no_auth","scriptName":"Order Chain [Kioseff Trading]","source":"// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// © KioseffTrading\r\n\r\n//@version=5\r\nindicator(\"Order Chain [Kioseff Trading]\", overlay = false, max_boxes_count = 500, max_labels_count = 500, max_bars_back = 500)\r\n\r\nchain    = input.int   (defval = 150,  minval = 5, title = \"Chain Length\", maxval = 450), var timeArr = array.new_int()\r\nhide     = input.bool  (defval = false ,           title = \"Hide Zero Values\"          )\r\nhideR    = input.bool  (defval = false,            title = \"Hide Range Boxes\"          )\r\nhideTick = input.bool  (defval = false,            title = \"Hide Tick Delta Stats\"     )\r\nminus    = input.color (defval = #FC8083,        title = \"-\", inline = \"col\"         )\r\nplus     = input.color (defval = #ADAEF4,        title = \"+\", inline = \"col\"         )\r\norderCol = input.color (defval = #08080B,        title = \"Order Text Color\"          )\r\nchainT   = input.string(defval = \"Auto\" ,          title = \"Chain Text Size\" , options = [\"Auto\", \"Tiny\", \"Small\", \"Normal\", \"Large\", \"Huge\"])\r\ndSize    = input.string(defval = \"Small\",          title = \"Delta Label Size\", options = [\"Auto\", \"Tiny\", \"Small\"])\r\n\r\nvar finSize  = switch dSize \r\n\r\n    \"Auto\"  => size.auto\r\n    \"Tiny\"  => size.tiny\r\n    \"Small\" => size.small\r\n\r\nvar finChain = switch chainT\r\n\r\n    \"Auto\"   => size.auto\r\n    \"Tiny\"   => size.tiny\r\n    \"Small\"  => size.small\r\n    \"Normal\" => size.normal\r\n    \"Large\"  => size.large\r\n    \"Huge\"   => size.huge\r\n\r\nimport RicardoSantos/MathOperator/2 \r\nimport PineCoders/Time/4 as pct \r\n\r\ntype tickData \r\n\r\n    varip float  price \r\n    varip float  volFlow\r\n    varip int    location\r\n    varip color  bgcol \r\n    varip float  delta \r\n    varip color  dCol\r\n    varip map   <string, float> relData\r\n    varip float  ticks\r\n    varip array<float> levels \r\n    array<chart.point> coords\r\n\r\n\r\ndirCol(float direction) => \r\n\r\n    switch math.sign(direction)\r\n\r\n        -1 => minus\r\n        1  => plus\r\n        =>     chart.fg_color\r\n\r\nmethod format(float value) => \r\n\r\n    switch \r\n\r\n        value < 1 and value > -1 => format.mintick \r\n        =>                          format.volume\r\n\r\nmethod unPop(array<int> id) => \r\n\r\n    if last_bar_index - bar_index <= 5000 \r\n        id.unshift(time)\r\n    \r\n    if id.size() > 5000\r\n        id.pop()\r\n\r\ntimeArr.unPop()\r\n\r\nif barstate.islast\r\n    if barstate.isrealtime  \r\n\r\n\r\n        varip vol = 0., varip vol1 = 0., varip c = 0., varip c1 = 0.    \r\n\r\n        varip ladder    = array.new<tickData>(3, tickData.new(delta = 0, dCol = chart.fg_color))    \r\n\r\n        varip keyValues = tickData.new(\r\n\r\n                                         relData = map.new<string, float>(),    \r\n\r\n                                         ticks   = syminfo.mintick * 50,    \r\n\r\n                                         levels  = \r\n                                             array.from(\r\n                                             close - syminfo.mintick * 50, \r\n                                             close, \r\n                                             close + syminfo.mintick * 50\r\n                                             ))\r\n\r\n\r\n\r\n        vol1 := vol, vol := volume, c1 := c, c := close \r\n\r\n        var priceLabs      = array.new<label>(2),\r\n        varip marketOrders = array.new<tickData>()\r\n        coords             = array.new<chart.point>()   \r\n\r\n        if keyValues.relData.size() == 0    \r\n\r\n            keyValues.relData.put(\"Top\", 0), keyValues.relData.put(\"Bot\", 20e25)\r\n            keyValues.relData.put(\"Abs\", 0), keyValues.relData.put(\"Max\",   0  )    \r\n\r\n        if math.max(keyValues.relData.get(\"Top\"), c).over(keyValues.levels.last())  \r\n\r\n            while keyValues.levels.last() < math.max(keyValues.relData.get(\"Top\"), c)\r\n\r\n                keyValues.levels.push(keyValues.levels.last().add(keyValues.ticks))\r\n                ladder.push(tickData.new(delta = 0, dCol = chart.fg_color)) \r\n\r\n        keyValues.relData.put(\"Top\", math.max(keyValues.relData.get(\"Top\"), keyValues.levels.last()))   \r\n\r\n        if math.min(keyValues.relData.get(\"Bot\"), c).under(keyValues.levels.first())    \r\n\r\n            while keyValues.levels.first() > math.min(keyValues.relData.get(\"Bot\"), c)  \r\n\r\n                keyValues.levels .unshift(keyValues.levels.first().subtract(keyValues.ticks))\r\n                ladder           .unshift(tickData.new(delta = 0, dCol = chart.fg_color))\r\n\r\n        keyValues.relData.put(\"Bot\", math.min(keyValues.relData.get(\"Bot\"), keyValues.levels.first()))  \r\n\r\n        if vol.over(vol1) and vol1.not_equal(0) and c.not_equal(c1)     \r\n\r\n            direction = math.sign(c - c1), col = dirCol(direction)  \r\n\r\n            marketOrders.push(tickData.new(c, vol.subtract(vol1).multiply(direction), 1, col))  \r\n\r\n            keyValues.relData.put(\"Abs\", math.max(keyValues.relData.get(\"Abs\"), (vol.subtract(vol1))))\r\n            keyValues.relData.put(\"Max\", math.max(keyValues.relData.get(\"Max\"),      c      ))  \r\n\r\n            indexof = keyValues.levels.binary_search_leftmost(c)\r\n            calc    = ladder.get(indexof).delta.add(vol.subtract(vol1).multiply(direction)) \r\n\r\n            ladder.set(indexof, tickData.new(delta = calc, dCol = dirCol(calc)))    \r\n\r\n        for BOX in box.all \r\n            BOX.delete()    \r\n\r\n        for poly in polyline.all \r\n            poly.delete()   \r\n\r\n        for lab in label.all\r\n            if not priceLabs.includes(lab)\r\n                lab.delete()    \r\n\r\n        if marketOrders.size() > chain\r\n            marketOrders.shift()\r\n\r\n        if marketOrders.size() > 1  \r\n\r\n            firstData  = marketOrders.last()    \r\n\r\n            Range = math.abs(keyValues.relData.get(\"Top\") - keyValues.relData.get(\"Bot\"))   \r\n\r\n            normedSize = (0.05 + 0.1 * math.abs(firstData.volFlow) / keyValues.relData.get(\"Abs\")) * Range * math.sign(firstData.volFlow)\r\n            normedX    = math.ceil((0.1 + 0.2 * math.abs(firstData.volFlow) / keyValues.relData.get(\"Abs\")) * 10)   \r\n\r\n            top = keyValues.relData.get(\"Top\")\r\n            bot = keyValues.relData.get(\"Bot\")  \r\n\r\n            box.new(\r\n            \r\n                     timeArr.get(normedX), firstData.price.add(normedSize), \r\n                     time, \r\n                     firstData.price                                                             , \r\n                     text           = str.tostring(firstData.volFlow, firstData.volFlow.format()), \r\n                     text_color     = orderCol, \r\n                     border_color   = #08080B, \r\n                     bgcolor        = color.new(firstData.bgcol, 33), \r\n                     xloc           = xloc.bar_time, \r\n                     text_size      = finChain\r\n\r\n                     )  \r\n\r\n\r\n            avg = math.avg(firstData.price.add(normedSize), firstData.price)    \r\n\r\n            coords.push(chart.point.from_time(math.round(math.avg(timeArr.get(normedX), time)) , avg))  \r\n\r\n            keyValues.relData.put(\"Top\", math.max(keyValues.relData.get(\"Top\"), firstData.price, firstData.price.add(normedSize)))\r\n            keyValues.relData.put(\"Bot\", math.min(keyValues.relData.get(\"Bot\"), firstData.price, firstData.price.add(normedSize)))  \r\n\r\n            for i = marketOrders.size() - 2 to 0    \r\n\r\n                getPrev = box.all.last(), getData = marketOrders.get(i) \r\n\r\n                normedSizeLoop = (0.05 + 0.1 * math.abs(getData.volFlow) / keyValues.relData.get(\"Abs\")) * Range * math.sign(getData.volFlow)\r\n                normedXLoop    = math.ceil((0.1 + 0.2 * math.abs(getData.volFlow) / keyValues.relData.get(\"Abs\")) * 10) \r\n\r\n                box.new(timeArr.get(timeArr.indexof(getPrev.get_left()) + getData.location + normedXLoop),  \r\n\r\n                                 getData.price.add(normedSizeLoop),\r\n                                 timeArr.get(timeArr.indexof(getPrev.get_left()) + getData.location), \r\n                                 getData.price                                                             , \r\n                                 text             = str.tostring(getData.volFlow, getData.volFlow.format()), \r\n                                 bgcolor          = color.new(getData.bgcol, 33), \r\n                                 text_color       = orderCol,\r\n                                 border_color     = #08080B,\r\n                                 xloc             = xloc.bar_time, \r\n                                 text_size        = finChain\r\n\r\n                                 )  \r\n\r\n                avgLoop = math.avg(getData.price.add(normedSizeLoop), getData.price)    \r\n\r\n                keyValues.relData.put(\"Top\", math.max(keyValues.relData.get(\"Top\"), firstData.price, getData.price.add(normedSizeLoop)))\r\n                keyValues.relData.put(\"Bot\", math.min(keyValues.relData.get(\"Bot\"), firstData.price, getData.price.add(normedSizeLoop)))    \r\n\r\n                coords.push(chart.point.from_time(timeArr.get(timeArr.indexof(getPrev.get_left()) + getData.location + 1), avgLoop))    \r\n\r\n            getLeft = box.all.last().get_left(), getBot = keyValues.relData.get(\"Bot\"), getTop = keyValues.relData.get(\"Top\")   \r\n\r\n            if not hideTick \r\n\r\n                switch na(priceLabs.first())    \r\n\r\n                    true =>  priceLabs.set(0, label.new(math.round(math.avg(getLeft, time)), \r\n                                                         getTop                                          , \r\n                                                         text      = str.tostring(getTop, format.mintick), \r\n                                                         textcolor = plus, \r\n                                                         color     = #00000000, \r\n                                                         size      = size.small,\r\n                                                         xloc      = xloc.bar_time\r\n                                                         )),    \r\n\r\n                             priceLabs.set(1, label.new(math.round(math.avg(getLeft, time)), \r\n                                                         getBot, \r\n                                                         text      = str.tostring(getBot, format.mintick), \r\n                                                         textcolor = minus, \r\n                                                         color     = #00000000, \r\n                                                         style     = label.style_label_up, \r\n                                                         size      = size.small, \r\n                                                         xloc      = xloc.bar_time\r\n                                                         )) \r\n\r\n                    =>          \r\n\r\n                             priceLabs.first().set_xy(math.round(math.avg(getLeft, time)), getTop),\r\n                             priceLabs.get(1) .set_xy(math.round(math.avg(getLeft, time)), getBot), \r\n\r\n                             priceLabs.first().set_text(str.tostring(getTop, format.mintick)),\r\n                             priceLabs.get(1) .set_text(str.tostring(getBot, format.mintick))   \r\n\r\n\r\n            if not hideR    \r\n\r\n                pineCoders = pct.timeFrom(\"bar\", 1, \"chart\")    \r\n\r\n                var upLine = line.new(getLeft, getBot, pineCoders, \r\n                                               getBot, \r\n                                               style = line.style_dotted, \r\n                                               color = color.new(minus, 25),\r\n                                               xloc  = xloc.bar_time    \r\n\r\n                                               )    \r\n\r\n                var dnLine = line.new(getLeft, getTop, pineCoders, \r\n                                               getTop, \r\n                                               style = line.style_dotted, \r\n                                               color = color.new(plus, 25),\r\n                                               xloc  = xloc.bar_time    \r\n\r\n                                               )    \r\n\r\n                var mdLine = line.new(getLeft, math.avg(getTop, getBot), pineCoders, \r\n                                               math.avg(getTop, getBot), \r\n                                               color = #00000000, \r\n                                               xloc  = xloc.bar_time\r\n                                               )    \r\n\r\n                upLine.set_xy1(getLeft, getBot), upLine.set_xy2(pineCoders, getBot)\r\n                dnLine.set_xy1(getLeft, getTop), dnLine.set_xy2(pineCoders, getTop)\r\n                mdLine.set_xy1(getLeft, math.avg(getTop, getBot)), mdLine.set_xy2(pineCoders, math.avg(getTop, getBot)) \r\n\r\n                linefill.new(upLine, mdLine, color.new(minus, 95))\r\n                linefill.new(dnLine, mdLine, color.new(plus, 95))   \r\n\r\n            polyline.new(coords, line_color = color.new(chart.fg_color, 50), curved = false, xloc = xloc.bar_time)  \r\n\r\n        for [i, level] in keyValues.levels  \r\n\r\n            if not hideTick \r\n\r\n                if not hide or hide and ladder.get(i).delta.not_equal(0)    \r\n\r\n                    if level.over_equal(c - keyValues.ticks * 100) and level.under_equal(c + keyValues.ticks * 100) \r\n\r\n                        finTxt = switch math.sign(ladder.get(i).delta)  \r\n\r\n                            0 => \"-\"\r\n                            =>   str.tostring(ladder.get(i).delta, format.volume)   \r\n\r\n\r\n                        label.new(bar_index + 1, level,  finTxt, \r\n                                                     style     = label.style_label_left, \r\n                                                     color     = #00000000, \r\n                                                     textcolor = ladder.get(i).dCol, \r\n                                                     size      = finSize\r\n                                                     )  \r\n\r\n\r\n    else \r\n\r\n        if timenow >= time_close\r\n\r\n            var t = table.new(position.middle_center, 99, 99)\r\n\r\n            t.cell(0, 0, text = \"This Indicator Works On Live Markets Without Bar Replay :D\",\r\n                                                     text_color = #FC8083, \r\n                                                     text_size = size.huge)\r\n\r\n    ","updated":"2024-03-05T11:55:11.732076Z","version":"2.0"}