{"created":"2023-09-17T09:00:00.484281Z","extra":{"kind":"study","sourceInputsCount":1},"lastVersionMaj":"1.0","scriptAccess":"open_no_auth","scriptName":"[Excalibur] Ehlers AutoCorrelation Periodogram Modified","source":"//@version=5\nindicator('[Excalibur] Ehlers AutoCorrelation Periodogram Modified', 'EACPM', false, format.price, 1)\n\ncolorize(series float power,\n         simple  bool originalColorScheme) =>\n    // Heatmap Color Helper Function\n    int red = 255\n    int grn = 0\n    if power > 0.5\n        grn := int(510.0 * (power - 0.5))\n    else\n        red := int(510.0 * power)\n    if grn == 255\n        color.rgb(red, grn, 180)\n    else\n        if originalColorScheme\n            color.rgb(red, grn, 0)\n        else\n            if power > 0.5\n                color.rgb(grn, grn, 255 - grn)\n            else\n                color.rgb(grn, 0, red)\n\nhp1st(series float Series,\n      simple float Period) =>\n    // John Ehlers' 1st Order High Pass Function\n    var float afreq =  2.0 * math.pi / Period\n    var float coef1 = (1.0 - math.sin(afreq)) / math.cos(afreq)\n    var float coef0 = (1.0 + coef1) * 0.5\n    float mom = Series - nz(Series[1], Series)\n    float  HP = na, HP := coef0 *    mom +\n                          coef1 * nz(HP[1])\n\nhp2nd(series float Series,\n      simple float Period) =>\n    // John Ehlers' 2nd Order High Pass Function\n    var float afreq =  math.sqrt( 2.0) * math.pi / Period\n    var float alpha = (math.cos(afreq) + math.sin(afreq) - 1.0) / math.cos(afreq)\n    var float coef0 =  math.pow(1.0 - alpha  / 2.0, 2.0)\n    var float coef1 =          (1.0 - alpha) * 2.0\n    var float coef2 =  math.pow(1.0 - alpha,   2.0)\n    float series1 = nz(Series[1], Series)\n    float whiten  =   (Series - 2.0 * series1 + nz(Series[2], series1))\n    float HP = na, HP := coef0 *    whiten +\n                         coef1 * nz(HP[1]) -\n                         coef2 * nz(HP[2])\n\nsups(series float Series,\n     simple float Period) =>\n    // John Ehlers' SuperSmoother Function\n    float smooth = na\n    if bar_index==0 or Period<2.0\n        smooth := Series\n    else\n        var float afreq =  math.sqrt(2.0) * math.pi / Period\n        var float alpha =  math.exp(-afreq)\n        var float coef2 = -math.pow( alpha,   2)\n        var float coef1 =  math.cos( afreq) * 2.0 * alpha\n        var float coef0 =  1.0 - coef1 - coef2\n        float     sma2  =  math.avg(Series, nz(Series[1], Series))\n        smooth := coef0 *     sma2      +\n                  coef1 * nz(smooth[1]) +\n                  coef2 * nz(smooth[2])\n\nroof(series float             Series=close,\n     simple float      LowPassPeriod=  7.5,    // Lowpass period of roofing filter\n     simple int       HighPassPeriod=   49,    // Highpass period of roofing filter\n     simple bool   HighPassSelection= true) => // Optional parameter to select either a 2nd or 1st order highpass filter for the roofing filter\n    // Custom Roofing Filter\n    switch HighPassSelection\n        true => sups(hp2nd(Series, HighPassPeriod), LowPassPeriod)\n        =>      sups(hp1st(Series, HighPassPeriod), LowPassPeriod)\n\n\nacs( series float     PassbandSeries,          // Passband series data on which a spectrum is to be generated from\n     simple int   AutoCorrelationLag=    3,    // AutoCorrelation lag period\n     simple float     PowerThreshold= 0.05,    // Threshold value to mitigate noisiness or sudden jumps in the dominant cycle\n     simple float           Contrast=  3.0,    // Value to improve contrast of color and the resolution of the spectral measurements\n     simple string   FourierFiltAlgo='ESS',    // Enables/disables smoothing of Fourier spectral components\n     simple int    FourierFiltPeriod=   10) => // Fourier filter smoothing period\n    // AutoCorrelation Spectrum Function\n    var     int autoCorrelationLag_M1 = AutoCorrelationLag - 1\n    var  array<float> aFourierFactors =  array.new<float>(50)\n    var matrix<float> mSmoothingCoefs = matrix.new<float>(50, 3)\n    if barstate.isfirst //⮟⮟⮟⮟⮟ Precalculate Coefficients and Fourier Factors ⮟⮟⮟⮟⮟\n        for int p=6 to 49\n            if FourierFiltAlgo == 'ESS'\n                float afreq =  math.sqrt(2.0) * math.pi / math.min(p, FourierFiltPeriod)\n                float alpha =  math.exp(-afreq)\n                float coef2 = -math.pow( alpha,   2) \n                float coef1 =  math.cos( afreq) * 2.0 * alpha\n                mSmoothingCoefs.set(p, 2,               coef2)\n                mSmoothingCoefs.set(p, 1,       coef1        )\n                mSmoothingCoefs.set(p, 0, 1.0 - coef1 - coef2)\n            else\n                float coef0 =  2.0 / (FourierFiltPeriod + 1)\n                mSmoothingCoefs.set(p, 1, 1.0 - coef0)\n                mSmoothingCoefs.set(p, 0,       coef0)\n            aFourierFactors.set(p, 2.0 * math.pi / p)\n    \n    float passbandSeries2           =  math.pow(PassbandSeries, 2)\n    array<float> aAutoCorrelationsR = array.new<float>(50, 0.0)\n    for int p=0 to 49 //⮟⮟⮟⮟⮟ Calculate AutoCorrelations ⮟⮟⮟⮟⮟\n        float Ex =0.0, float Ey =0.0, float Exy=0.0\n        float Exx=0.0, float Eyy=0.0\n        for int i=0 to autoCorrelationLag_M1\n            float t = i + p\n            float X = nz(PassbandSeries[i])\n    \t\tfloat Y = nz(PassbandSeries[t])\n            Ex  += X\n            Exy += X * Y\n    \t    Ey  +=     Y\n            Exx += nz(passbandSeries2[i])\n            Eyy += nz(passbandSeries2[t])\n        float numerator   =  (AutoCorrelationLag * Exy - Ex * Ey)\n        float denominator =  (AutoCorrelationLag * Exx - Ex * Ex) *\n                             (AutoCorrelationLag * Eyy - Ey * Ey)\n    \tif denominator > 0.0\n            aAutoCorrelationsR.set(p, numerator / math.sqrt(denominator))\n    \n    array<float> aSpectralComps = array.new<float>(50)\n    for int p=6 to 49 //⮟⮟⮟⮟⮟ Decompose Fourier Components ⮟⮟⮟⮟⮟\n        float realPart = 0.0\n    \tfloat imagPart = 0.0\n        float angularFreqFactor = aFourierFactors.get(p)\n        for int i=0 to 49\n            float ACi = aAutoCorrelationsR.get(i)\n    \t\trealPart += math.cos(angularFreqFactor * i) * ACi\n    \t\timagPart += math.sin(angularFreqFactor * i) * ACi\n    \taSpectralComps.set(p, math.pow(realPart, 2) +\n                              math.pow(imagPart, 2))\n    \n    array<float> aSmoothedFourierComps = array.new<float>(50)\n    switch FourierFiltAlgo\n        'ESS' =>\n            for int p=6 to 49 //⮟⮟⮟⮟⮟ Fourier Components SuperSmoothed ⮟⮟⮟⮟⮟\n                float currFourierMagnitude = aSpectralComps.get(p)\n                float superSmoothCoef2    = mSmoothingCoefs.get(p, 2)\n                float superSmoothCoef1    = mSmoothingCoefs.get(p, 1)\n                float superSmoothCoef0    = mSmoothingCoefs.get(p, 0)\n                float lastFourierSmoothed = currFourierMagnitude\n                float prevFourierSmoothed = currFourierMagnitude\n                if not na(aSmoothedFourierComps[1]) // Check for prior series array NOT being `na`(undefined)\n                    lastFourierSmoothed := array.get(aSmoothedFourierComps[1], p) // Obtains last existing series array element\n                    if not na(aSmoothedFourierComps[2]) // Check for prior series array NOT being `na`(undefined)\n                        prevFourierSmoothed := array.get(aSmoothedFourierComps[2], p) // Obtains previous existing series array element\n                    else\n                        prevFourierSmoothed := lastFourierSmoothed // Substitution value when `na` is present\n                aSmoothedFourierComps.set(p, superSmoothCoef0 * currFourierMagnitude +\n                                             superSmoothCoef1 *  lastFourierSmoothed +\n                                             superSmoothCoef2 *  prevFourierSmoothed) // SuperSmoother Coefficients on Fourier series arrays\n        'EMA' =>\n            for int p=6 to 49 //⮟⮟⮟⮟⮟ Fourier Components EMA Smoothed ⮟⮟⮟⮟⮟\n                float currFourierMagnitude = aSpectralComps.get(p)\n                float lastFourierSmoothed  = currFourierMagnitude\n                if not na(aSmoothedFourierComps[1]) // Check for prior series array NOT being `na`(undefined)\n                    lastFourierSmoothed := array.get(aSmoothedFourierComps[1], p) // Obtains last existing series array element\n                aSmoothedFourierComps.set(p, mSmoothingCoefs.get(p, 0) * currFourierMagnitude +\n                                             mSmoothingCoefs.get(p, 1) * lastFourierSmoothed) // Ehlers' original EMA on Fourier series arrays\n        => // 'NONE'\n            for int p=6 to 49\n                aSmoothedFourierComps.set(p, aSpectralComps.get(p))\n    \n    float peakPower = aSmoothedFourierComps.get(6)\n    for int p=7 to 49 //⮟⮟⮟⮟⮟ Find Peak Power Component ⮟⮟⮟⮟⮟\n        float spectralComponent = aSmoothedFourierComps.get(p)\n        if spectralComponent > peakPower\n    \t    peakPower := spectralComponent\n    \n    float dividend = 0.0\n    float divisor  = 0.0\n    for int p=6 to 49 //⮟⮟⮟⮟⮟ Determine Dominant Cycle Period ⮟⮟⮟⮟⮟\n        float spectriNormalized = math.pow(aSmoothedFourierComps.get(p) / peakPower, Contrast)\n        if spectriNormalized > PowerThreshold\n            dividend += spectriNormalized * p\n            divisor  += spectriNormalized\n        aSpectralComps.set(p, spectriNormalized) // Reassign normalized spectral components for periodogram\n    var float DOMINANT_CYCLE = 7\n    if divisor > 0.25\n        DOMINANT_CYCLE := math.max(7, dividend / divisor)\n    \n    [DOMINANT_CYCLE, aSpectralComps] // tuple returns\n\n\nstring grp0 = 'Source Options'\nstring selectSourceOrSine  = input.string('Source', 'Source Selection', group=grp0, inline='1', options=['Source','SineWave'])\nfloat  source              = input.source(   hlcc4,                 '', group=grp0, inline='1', tooltip='This can be sourced to other generators/indicators')\nfloat  sineWavePeriod      = input.float (    16.0,'  SineWave Period', group=grp0, minval=6.0, tooltip='Wavelength of the sinusoidal wave in bars')\nstring grp1 = 'Roofing Filter Options'\nfloat  roofingFilterLP     = input.float (  7.5, 'Roofing Filter: Low-Pass Period', group=grp1,  minval=7.0,  step=0.5,   maxval=30.0)\nint    roofingFilterHP     = input.int   (   49,         '       High-Pass Period', group=grp1,  minval=49)\nbool   highpassSelection   = input.bool  ( true,    '     High-Pass Filter Choice', group=grp1, tooltip=\"true == Ehlers' 2nd Order High Pass\\nfalse == Ehlers' 1st Order High Pass\")\nstring grp2 = 'Spectral Controls'\nint    autoCorrelationLag  = input.int   (    3,      'AutoCorrelation Lag', group=grp2, minval=2)\nstring fourierCoefsFilter  = input.string('ESS', 'Fourier Smoothing Method', group=grp2, inline='2', options=['ESS','EMA','NONE'], tooltip=\"ESS -> Ehlers' SuperSmoother\\nEMA -> Basic EMA\")\nint    fourierSmoothPeriod = input.int   (    9,                         '', group=grp2, inline='2',  minval=7)\nfloat  powerThreshold      = input.float ( 0.05,          'Power Threshold', group=grp2, minval=0.05,   step=0.05, tooltip='This affects the spectral values')\nfloat  heatMapContrast     = input.float (  2.5,         'HeatMap Contrast', group=grp2, minval=1.0,    step=0.5,  tooltip='This affects both the coloring and the spectral values')\nbool   heatMapColorScheme  = input.bool  ( true,    'Original Color Scheme', group=grp2)\nstring grp3 = 'Dominant Cycle Options'\nstring dominantCycleType   = input.string(   'Float',   'Dominant Cycle Type', group=grp3, options=['Float','Integer*'])\nstring dominantCycleForm   = input.string('Smoothed',   'Dominant Cycle Form', group=grp3, options=['Smoothed','Floor*','Round*'])\nfloat  smoothDominantCycle = input.float (       7.0, 'Smooth Dominant Cycle', group=grp3,  minval=1.0)\n\nfloat price                              = selectSourceOrSine=='Source' ? source * 10.0 : math.sin(bar_index * 6.2831853 / sineWavePeriod) * 21.0 + 28.0\nfloat roofingFilter                      = roof(price, roofingFilterLP, roofingFilterHP, highpassSelection)\n[dominantCycle, aSpectralPowerEstimates] =  acs(roofingFilter, autoCorrelationLag, powerThreshold, heatMapContrast, fourierCoefsFilter, fourierSmoothPeriod)\n\ndominantCycle := if dominantCycleType=='Integer*'\n    switch dominantCycleForm\n        'Round*' => int(math.round(dominantCycle))\n        =>          int(           dominantCycle)\nelse\n    switch dominantCycleForm\n        'Smoothed' => math.max(7.0, sups(dominantCycle, smoothDominantCycle))\n        'Round*'   => math.round(dominantCycle)\n        =>            math.floor(dominantCycle)\n\nplot(selectSourceOrSine=='Source' ? na : price, 'SineWave', #FFFFFF)\nplot(                            dominantCycle,   'DomCyc', #8000FF, 2)\n\n//===== The Periodogram =====//\nvar hline06 = hline( 6, color=#00000000), var hline07 = hline( 7, color=#00000000), var hline08 = hline( 8, color=#00000000), var hline09 = hline( 9, color=#00000000), var hline10 = hline(10, color=#00000000)\nvar hline11 = hline(11, color=#00000000), var hline12 = hline(12, color=#00000000), var hline13 = hline(13, color=#00000000), var hline14 = hline(14, color=#00000000), var hline15 = hline(15, color=#00000000)\nvar hline16 = hline(16, color=#00000000), var hline17 = hline(17, color=#00000000), var hline18 = hline(18, color=#00000000), var hline19 = hline(19, color=#00000000), var hline20 = hline(20, color=#00000000)\nvar hline21 = hline(21, color=#00000000), var hline22 = hline(22, color=#00000000), var hline23 = hline(23, color=#00000000), var hline24 = hline(24, color=#00000000), var hline25 = hline(25, color=#00000000)\nvar hline26 = hline(26, color=#00000000), var hline27 = hline(27, color=#00000000), var hline28 = hline(28, color=#00000000), var hline29 = hline(29, color=#00000000), var hline30 = hline(30, color=#00000000)\nvar hline31 = hline(31, color=#00000000), var hline32 = hline(32, color=#00000000), var hline33 = hline(33, color=#00000000), var hline34 = hline(34, color=#00000000), var hline35 = hline(35, color=#00000000)\nvar hline36 = hline(36, color=#00000000), var hline37 = hline(37, color=#00000000), var hline38 = hline(38, color=#00000000), var hline39 = hline(39, color=#00000000), var hline40 = hline(40, color=#00000000)\nvar hline41 = hline(41, color=#00000000), var hline42 = hline(42, color=#00000000), var hline43 = hline(43, color=#00000000), var hline44 = hline(44, color=#00000000), var hline45 = hline(45, color=#00000000)\nvar hline46 = hline(46, color=#00000000), var hline47 = hline(47, color=#00000000), var hline48 = hline(48, color=#00000000), var hline49 = hline(49, color=#00000000), var hline50 = hline(50, color=#00000000)\n\nfill(hline06, hline07, colorize(aSpectralPowerEstimates.get( 6), heatMapColorScheme))\nfill(hline07, hline08, colorize(aSpectralPowerEstimates.get( 7), heatMapColorScheme))\nfill(hline08, hline09, colorize(aSpectralPowerEstimates.get( 8), heatMapColorScheme))\nfill(hline09, hline10, colorize(aSpectralPowerEstimates.get( 9), heatMapColorScheme))\nfill(hline10, hline11, colorize(aSpectralPowerEstimates.get(10), heatMapColorScheme))\nfill(hline11, hline12, colorize(aSpectralPowerEstimates.get(11), heatMapColorScheme))\nfill(hline12, hline13, colorize(aSpectralPowerEstimates.get(12), heatMapColorScheme))\nfill(hline13, hline14, colorize(aSpectralPowerEstimates.get(13), heatMapColorScheme))\nfill(hline14, hline15, colorize(aSpectralPowerEstimates.get(14), heatMapColorScheme))\nfill(hline15, hline16, colorize(aSpectralPowerEstimates.get(15), heatMapColorScheme))\nfill(hline16, hline17, colorize(aSpectralPowerEstimates.get(16), heatMapColorScheme))\nfill(hline17, hline18, colorize(aSpectralPowerEstimates.get(17), heatMapColorScheme))\nfill(hline18, hline19, colorize(aSpectralPowerEstimates.get(18), heatMapColorScheme))\nfill(hline19, hline20, colorize(aSpectralPowerEstimates.get(19), heatMapColorScheme))\nfill(hline20, hline21, colorize(aSpectralPowerEstimates.get(20), heatMapColorScheme))\nfill(hline21, hline22, colorize(aSpectralPowerEstimates.get(21), heatMapColorScheme))\nfill(hline22, hline23, colorize(aSpectralPowerEstimates.get(22), heatMapColorScheme))\nfill(hline23, hline24, colorize(aSpectralPowerEstimates.get(23), heatMapColorScheme))\nfill(hline24, hline25, colorize(aSpectralPowerEstimates.get(24), heatMapColorScheme))\nfill(hline25, hline26, colorize(aSpectralPowerEstimates.get(25), heatMapColorScheme))\nfill(hline26, hline27, colorize(aSpectralPowerEstimates.get(26), heatMapColorScheme))\nfill(hline27, hline28, colorize(aSpectralPowerEstimates.get(27), heatMapColorScheme))\nfill(hline28, hline29, colorize(aSpectralPowerEstimates.get(28), heatMapColorScheme))\nfill(hline29, hline30, colorize(aSpectralPowerEstimates.get(29), heatMapColorScheme))\nfill(hline30, hline31, colorize(aSpectralPowerEstimates.get(30), heatMapColorScheme))\nfill(hline31, hline32, colorize(aSpectralPowerEstimates.get(31), heatMapColorScheme))\nfill(hline32, hline33, colorize(aSpectralPowerEstimates.get(32), heatMapColorScheme))\nfill(hline33, hline34, colorize(aSpectralPowerEstimates.get(33), heatMapColorScheme))\nfill(hline34, hline35, colorize(aSpectralPowerEstimates.get(34), heatMapColorScheme))\nfill(hline35, hline36, colorize(aSpectralPowerEstimates.get(35), heatMapColorScheme))\nfill(hline36, hline37, colorize(aSpectralPowerEstimates.get(36), heatMapColorScheme))\nfill(hline37, hline38, colorize(aSpectralPowerEstimates.get(37), heatMapColorScheme))\nfill(hline38, hline39, colorize(aSpectralPowerEstimates.get(38), heatMapColorScheme))\nfill(hline39, hline40, colorize(aSpectralPowerEstimates.get(39), heatMapColorScheme))\nfill(hline40, hline41, colorize(aSpectralPowerEstimates.get(40), heatMapColorScheme))\nfill(hline41, hline42, colorize(aSpectralPowerEstimates.get(41), heatMapColorScheme))\nfill(hline42, hline43, colorize(aSpectralPowerEstimates.get(42), heatMapColorScheme))\nfill(hline43, hline44, colorize(aSpectralPowerEstimates.get(43), heatMapColorScheme))\nfill(hline44, hline45, colorize(aSpectralPowerEstimates.get(44), heatMapColorScheme))\nfill(hline45, hline46, colorize(aSpectralPowerEstimates.get(45), heatMapColorScheme))\nfill(hline46, hline47, colorize(aSpectralPowerEstimates.get(46), heatMapColorScheme))\nfill(hline47, hline48, colorize(aSpectralPowerEstimates.get(47), heatMapColorScheme))\nfill(hline48, hline49, colorize(aSpectralPowerEstimates.get(48), heatMapColorScheme))\nfill(hline49, hline50, colorize(aSpectralPowerEstimates.get(49), heatMapColorScheme))","updated":"2023-09-17T09:00:00.484281Z","version":"1.0"}