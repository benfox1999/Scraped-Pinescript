{"created":"2023-11-05T19:27:02.451917Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"3.0","scriptAccess":"open_no_auth","scriptName":"Sync Frame [Kioseff Trading]","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© KioseffTrading\n\n//@version=5\nindicator(\"Sync Frame [Kioseff Trading]\", overlay = true, max_boxes_count = 500, max_lines_count = 500)\n\nimport RicardoSantos/MathOperator/2\nimport HeWhoMustNotBeNamed/arraymethods/1\n\n\nHA       = input.string(defval = \"Traditional\", title = \"Candle Type\", options = [\"Traditional\", \"Heikin Ashi\", \"Baseline\"])\nautox    = input.bool  (defval = true, title = \"Auto Scale X-Axis\")\nlin      = input.bool  (defval = true, title = \"Show Lin Reg\")\nlen      = input.int   (defval = 90, minval = 3, maxval = 90, title = \"Intrabars\")\nupcol    = input.color (defval = #14D990, title = \"Up Color\", inline = \"C\")\ndncol    = input.color (defval = #F24968, title = \"Up Color\", inline = \"C\")\n\nusert    = input.bool  (defval = false, title = \"Use Custom Timeframes\", group = \"Custom Timeframes\")\nusert1   = input.int   (defval = 1, minval = 1, title = \"TF 1\", group = \"Custom Timeframes\")\nusert2   = input.int   (defval = 2, minval = 1, title = \"TF 2\", group = \"Custom Timeframes\")\nusert3   = input.int   (defval = 3, minval = 1, title = \"TF 3\", group = \"Custom Timeframes\")\nusert4   = input.int   (defval = 4, minval = 1, title = \"TF 4\", group = \"Custom Timeframes\"), var shif    = 25\nusert5   = input.int   (defval = 5, minval = 1, title = \"TF 5\", group = \"Custom Timeframes\"), var counter = 0\n\n\nroundedCountRaw = int(counter * .01)\nroundedCount    = switch autox \n\n    true => math.max(math.min(roundedCountRaw, math.floor(475 / len)), 2)\n    =>      2\n\nmethod float(int int) => float(int)\n\nstrMax( float , userTime) =>\n\n    seconds = timeframe.in_seconds(timeframe.period)\n\n    mult = seconds / 6\n\n    switch \n\n        not usert => timeframe.from_seconds(seconds - mult * float)\n        =>           str.tostring(userTime)\n\n\nreq(autoTime, userTime) => \n\n    modify = switch HA \n\n        \"Heikin Ashi\"  => ticker.heikinashi(syminfo.tickerid)\n        =>                syminfo.tickerid \n\n    [o, h, l, c] = request.security_lower_tf(modify, strMax(autoTime, userTime), [open, high, low, close], ignore_invalid_timeframe = true)\n\n[o1, h1, l1, c1]     = req(1, usert1), [o2, h2, l2, c2]     = req(2, usert2)\n[o3, h3, l3, c3]     = req(3, usert3), [o4, h4, l4, c4]     = req(4, usert4),\n                     [o5, h5, l5, c5]     = req(5, usert5)\n\n\ntype lowTFs \n\n    matrix<float> lowTF1\n    matrix<float> lowTF2 \n    matrix<float> lowTF3 \n    matrix<float> lowTF4\n    matrix<float> lowTF5\n    box  candles \n    line HlWick\n\nvar HlMat = matrix.new<float>(2, 1)\n\nswitch \n\n    barstate.isfirst                                                             =>  HlMat.set(0, 0, -1e8),      HlMat.set(1, 0, 1e8)\n    time >= chart.left_visible_bar_time and time <= chart.right_visible_bar_time =>  HlMat.set(0, 0, math.max(high, HlMat.get(0, 0))), \n                                                                                     HlMat.set(1, 0, math.min(low , HlMat.get(1, 0)))\n\n\nmethod matrixApp(matrix<float> id, Close, High, Low, Open, autoTime, userTime) => \n\n    timeNeeded = math.ceil(len / (timeframe.in_seconds(timeframe.period) / timeframe.in_seconds(strMax(autoTime, userTime))))\n\n    if last_bar_index - bar_index <= timeNeeded * 4 // multiplied for non-24 hour markets\n\n        for i = 0 to Close.size() - 1 \n\n            id.add_col(0, array.from(Close.get(i), High.get(i), Low.get(i), Open.get(i)))\n    \n    id\n\nmethod sliceFun(matrix<float> id) => \n\n    all = array.new_float()\n\n    c = id.row(0).slice(0, len), h = id.row(1).slice(0, len)\n    l = id.row(2).slice(0, len), o = id.row(3).slice(0, len)\n\n    for i = 0 to c.size() - 1 \n\n        all.push(c.get(i)), all.push(h.get(i))\n        all.push(l.get(i)), all.push(o.get(i))\n\n    [c, h, l, o, all]\n\nmethod normalize(array<float> id, i, newMin, newMax, idMax, idMin) => \n\n    id.set(i, newMin + ((id.get(i) - idMin) * (newMax - newMin)) / (idMax - idMin))\n\n\nmethod norm(matrix<float> id, int mult) => \n\n    rang = (HlMat.get(0, 0) - HlMat.get(1, 0)) / 5\n\n    newMin = HlMat.get(1, 0) + rang * mult \n    newMax = HlMat.get(1, 0) + rang * (mult + 1)\n\n    [closes, highs, lows, opens, all] = id.sliceFun()\n\n    allMax = all.max(), allMin = all.min()\n\n    for i = 0 to closes.size() - 1 \n\n        closes.normalize(i, newMin, newMax, allMax, allMin)\n        opens .normalize(i, newMin, newMax, allMax, allMin)\n        highs .normalize(i, newMin, newMax, allMax, allMin)\n        lows  .normalize(i, newMin, newMax, allMax, allMin)\n\n    [closes, opens, highs, lows]\n\nvar allSlopes = array.new_float(), var linRegLine = array.new_line(), var fillLine = array.new_line()\n\nmethod linReg(matrix<float> id, mult, mult2, userTime, autoTime) => \n\n    if barstate.islast and lin and HA != \"Baseline\" \n\n        [clo, ope, hi, lo] = id.norm(mult2 - 1)\n\n        linReg = matrix.new<float>(4, clo.size())\n\n        for i = 0 to clo.size() - 1\n\n            linReg.set(0, i, i + 1), linReg.set(1, i, clo.get(i))\n\n        b = linReg.row(0)\n\n        for i = 0 to clo.size() - 1\n\n            linReg.set(2, i, math.pow(b.get(i) - b.avg(), 2))\n            linReg.set(3, i, (b.get(i) - b.avg()) * (linReg.row(1).get(i) - linReg.row(1).avg()))\n\n        bx = linReg.row(3).sum() / linReg.row(2).sum() \n        mx = linReg.row(1).avg() - (bx * b.avg())\n\n        coord = switch bx.over_equal(0)\n\n            true => hi.max() \n            =>      lo.min()\n\n        fillLine.push  (line.new(bar_index + shif, coord,   bar_index + shif +  clo.size() * roundedCount + 5, coord, color = #00000000))\n        linRegLine.push(line.new(bar_index + shif, (bx * clo.size() + mx), bar_index + shif +  clo.size() * roundedCount + 5, bx + mx, \n                                             width = 1, style = line.style_solid))  \n\n        allSlopes.push(bx * -1)\n\n\nmethod draw(matrix<float> id, mult, userTime) => \n\n    if barstate.islast\n\n        [clo, ope, hi, lo] = id.norm(mult - 1)\n\n        baseline = math.avg(hi.max(), lo.min()), baseLine = array.new_line()\n\n        candleDraw = matrix.new<lowTFs>(2, 0)\n\n        trueClo = id.row(0).slice(0, len)\n\n        val = switch \n\n            hi.max().subtract(clo.first()).over_equal(clo.first().subtract(lo.min())) => text.align_bottom\n            =>                                                                           text.align_top\n    \n\n        box.new(bar_index + shif, hi.max(), bar_index + len * roundedCount + shif + 5, lo.min(), bgcolor = HA == \"Baseline\" ? na : color.new(#000eff, 90),\n                                                             border_color = #363843,\n             text = strMax(mult, userTime) + \" (\" + str.tostring((trueClo.first() / trueClo.last() - 1) * 100, format.percent) + \")\",\n             text_color = color.white, text_valign = val, text_halign = text.align_left, text_size = size.tiny)\n\n        if HA == \"Baseline\" \n\n            bl = line.new(bar_index + shif, baseline, bar_index + len * roundedCount + shif + 5, baseline, color = color.white, \n                                                     style = line.style_dashed)\n\n            ul = line.new(bar_index + shif, hi.max(), bar_index + len * roundedCount + shif + 5, hi.max(), color = #00000000)\n            ll = line.new(bar_index + shif, lo.min(), bar_index + len * roundedCount + shif + 5, lo.min(), color = #00000000)\n        \n            linefill.new(ul, bl, color.new(upcol, 90))\n            linefill.new(ll, bl, color.new(dncol, 90))\n\n\n\n        if HA != \"Baseline\"\n\n            initialCol = switch id.get(0, 0).over_equal(id.get(3, 0))\n\n                true  =>  upcol\n                false =>  dncol\n\n\n            candleDraw.add_col(candleDraw.columns(), array.from(\n\n                 lowTFs.new(candles = box.new(bar_index + shif + 2 + len * roundedCount, clo.first(), bar_index + shif + 4 + len * roundedCount, ope.first(), \n                             bgcolor = initialCol , border_color = na)),\n                        \n                 lowTFs.new(HlWick = line.new(bar_index + shif + 3 + len * roundedCount, hi.first(), bar_index + shif + 3 + len * roundedCount, lo.first (), \n                             color = initialCol))\n                 \n                     ))\n\n            for i = 1 to len - 1\n\n                col = switch id.get(0, i).over_equal(id.get(3, i)) \n\n                    true  =>  upcol\n                    false =>  dncol\n\n                \n                getLeft  = candleDraw.get(0, candleDraw.columns() - 1).candles.get_left()\n                pAvg     = math.round(math.avg(getLeft - roundedCount, getLeft))\n\n                candleDraw.add_col(candleDraw.columns(), array.from(\n\n                         lowTFs.new(candles = box.new(getLeft - roundedCount, clo.get(i), getLeft,\n                                             ope.get(i), bgcolor = col , border_color = na)), \n\n                         lowTFs.new(HlWick  = line.new(pAvg, hi.get(i), pAvg, lo.get(i), color = col))\n\n                     ))\n\n                if box.all.size() > 499\n                    box.all.remove(1).delete()\n\n                if line.all.size() > 490\n\n                    count = 0.\n\n                    for x = 0 to line.all.size() - 1\n\n                        if count.equal(2) \n                            break\n\n                        else \n\n                            if not linRegLine.includes(line.all.get(x)) \n                                if not fillLine.includes(line.all.get(x))\n\n                                    line.all.remove(x).delete()\n                                    count += 1 \n\n        else \n\n            baseLine.push(line.new(bar_index + shif + 2 + len * roundedCount, clo.get(1), bar_index + shif + 4 + len * roundedCount, clo.first(), \n                             color = clo.first() > baseline ? upcol : dncol))\n\n            for i = 1 to len - 2\n\n                if clo.get(i).over(baseline) and clo.get(i + 1).under(baseline) \n                  or clo.get(i).under(baseline) and clo.get(i + 1).over(baseline)\n\n                    [col1, col2] = switch \n                        \n                        clo.get(i) >= baseline => [upcol, dncol]\n                        =>                        [dncol, upcol]\n\n                    baseLine.push(line.new(baseLine.last().get_x1() - math.round(roundedCount / 2), baseline, baseLine.last().get_x1(),\n                      clo.get(i), color =col1))\n\n                    baseLine.push(line.new(baseLine.last().get_x1() - math.round(roundedCount / 2), clo.get(i + 1), baseLine.last().get_x1(),\n                      baseline, color =  col2))\n\n                else \n\n                    baseLine.push(line.new(baseLine.last().get_x1() - roundedCount, clo.get(i + 1), baseLine.last().get_x1(),\n                          clo.get(i), color = clo.get(i) >= baseline ? upcol : dncol))\n\n        id\n\nif last_bar_index - bar_index <= 500\n\n    box.all.flush(), label.all.flush(), line.all.flush()\n\n    var ltf = lowTFs.new(matrix.new<float>(4, 0), matrix.new<float>(4, 0), matrix.new<float>(4, 0), matrix.new<float>(4, 0), matrix.new<float>(4, 0)) \n\n    ltf.lowTF1.matrixApp(c1, h1, l1, o1, 1, usert1).draw(1, usert1).linReg(1, 1, usert1, 1) \n    ltf.lowTF2.matrixApp(c2, h2, l2, o2, 2, usert2).draw(2, usert2).linReg(1, 2, usert2, 2)     \n    ltf.lowTF3.matrixApp(c3, h3, l3, o3, 3, usert3).draw(3, usert3).linReg(1, 3, usert3, 3) \n    ltf.lowTF4.matrixApp(c4, h4, l4, o4, 4, usert4).draw(4, usert4).linReg(1, 4, usert4, 4) \n    ltf.lowTF5.matrixApp(c5, h5, l5, o5, 5, usert5).draw(5, usert5).linReg(1, 5, usert5, 5)\n\n    if lin \n\n        if barstate.islast\n\n            copySlope = allSlopes.copy()\n\n            copySlope.sort(order.ascending)\n\n            var float [] ups = na, var float [] dns = na\n\n            if allSlopes.max().over_equal(0)\n\n                ups := copySlope.slice(copySlope.binary_search_rightmost(0), copySlope.size())\n\n                for i = 0 to ups.size() - 1\n\n                    col = color.from_gradient(ups.get(i), 0, ups.max(), color.white, upcol)\n\n                    linRegLine.get(allSlopes.indexof(ups.get(i))).set_color(col)\n                    linefill.new(linRegLine.get(allSlopes.indexof(ups.get(i))), fillLine.get(allSlopes.indexof(ups.get(i))), color.new(col, 75))\n\n            if allSlopes.min().under(0) \n\n                dns := copySlope.slice(0, copySlope.binary_search_rightmost(0))\n\n                for i = 0 to dns.size() - 1\n\n                    col = color.from_gradient(dns.get(i), dns.min(), 0, dncol, color.white)\n\n                    linRegLine.get(allSlopes.indexof(dns.get(i))).set_color(col)\n                    linefill.new(linRegLine.get(allSlopes.indexof(dns.get(i))), fillLine.get(allSlopes.indexof(dns.get(i))), color.new(col, 75))\n\n\nif time >= chart.left_visible_bar_time\n    counter += 1","updated":"2023-11-05T19:27:02.451917Z","version":"3.0"}