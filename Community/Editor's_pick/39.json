{"created":"2023-09-29T01:11:01.801002Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"3.0","scriptAccess":"open_no_auth","scriptName":"Monte Carlo Simulation [Kioseff Trading]","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © KioseffTrading\n\n//@version=5\nindicator(\"Monte Carlo Simulation [Kioseff Trading]\", max_lines_count = 500, overlay = false, max_labels_count = 500, max_boxes_count = 500)\n\njustPriceS = input.string   (defval = \"Price\",  title = \"I Want To Simulate: \", options = [\"Price\" , \"My Strategy\"])\nseed       = input.int      (defval = 0, title = \"Set Seed\", minval = 0)\ndistT      = input.string   (defval = \"Normal\", title = \"Type\", options = [\"Normal\", \"Bootstrap\"])\ntxt        = input.text_area(defval = \"-3\\n-2\\n-1\\n0\\n1\\n2\\n3\\n *If You Selected 'My Strategy'\\n(Paste Your Returns Here Following This Format)\", title =\"Returns\")\ncumu       = input.float    (defval = 70, title = \"Cumulative Probability Target\", maxval = 99, minval = 5) / 100\nlin        = input.bool     (defval = false,  title = \"Line Plot Only\")\nlab        = input.bool     (defval = false,  title = \"Represent With Circles\")\nhist       = input.bool     (defval = false,  title = \"Probability Distribution Only\")\nbinT       = input.string   (defval = \"Rice\", title = \"Binning Method\", options = [\"Sturges\", \"Rice\", \"Square Root\", \"Custom\"])\nsims       = input.int      (defval = 250,    title = \"Simulations\", minval = 1)\nforx       = input.int      (defval = 15,     title = \"Forecast\") + 1\nonly       = input.bool     (defval = false,  title = \"Show Best Case / Worst Case Only\")\nback       = input.int      (defval = 200,    title = \"Historical Data Points\", minval = 5, group = \"Simulate Price Instead\", step = 10)\nlineS      = input.string   (defval = \"Solid\", title = \"Line Style\", options= [\"Solid\", \"Dotted\", \"Dashed\"], group = \"Line Style\")\n\nfinS = switch lineS\n\n    \"Dotted\" => line.style_dotted\n    \"Solid\"  => line.style_solid\n    \"Dashed\" => line.style_dashed\n\nvar ret    = array.new_float(), endPoints = array.new_float()\n\njustPrice = justPriceS == \"Price\"\n\nif lab \n    only := false\n    hist := false\n\nif hist \n    only := false\n    lin  := false\n    \nbinSize(size) =>  \n\n    switch binT \n        \n        \"Square Root\" => math.sqrt(size) \n        \"Rice\"        => 2 * (math.pow(size, 1./3))\n        \"Sturges\"     => math.log(size) / math.log(2) + 1, \n        \"Custom\"      => input.int(20, title = \"Custom Bin Amount (If Selected)\", minval = 5, maxval = 200, group = \"Custom Bin Amount\")\n\ntxt2       = input.text_area(defval = \"\",     title = \"Additional Returns\")\ntxt3       = input.text_area(defval = \"\",     title = \"Additional Returns\")\ntxt4       = input.text_area(defval = \"\",     title = \"Additional Returns\")\n\n\nGauss(z, avg, std) => \n    \n    avg + std * z\n\nmethod boot(array <float> id) => \n\n\n    id.get(int(math.random(0, id.size(), seed)))\n\ndistribution() => \n\n    avg    = ret.avg(), std = ret.stdev(false), size = ret.size()\n    r1     = math.random(0.01, 0.99, seed)\n    r2     = math.random(0.01, 0.99, seed)  \n    result = math.sqrt  (-2.0 * math.log(r1)) * math.cos(2.0 * math.pi * r2)\n\n    switch distT\n\n        \"Normal\"   => Gauss(result, avg, std)\n        =>            ret.boot()\n\n\nmethod num(float id, val) => \n\n    switch justPrice \n\n        false => id + val \n        =>       id * math.exp(val)\n\nmethod dete (matrix <float> id, val, i, x, int col, matrix<color> id2, color val2) => \n\n    if not lab\n\n        if i < id.rows()\n\n            id.set (i, col, val)\n            id2.set(i, col, val2)\n    else \n        \n        if x == forx - 1 and i < 1000\n\n            id .set(i, 0, val)\n            id2.set(i, 0, val2)\n\natr = ta.atr(14)\n\nmethod mult(float id, up = 1.002, dn = .998) =>\n    \n    switch \n\n        justPrice           => id - atr\n        math.sign(id) == -1 => id * up\n        math.sign(id) == 1  => id * dn\n\nif last_bar_index - bar_index <= back and justPrice \n\n    ret.push(math.log(close / close[1]))\n\nmethod iSwitch(matrix <float> id, lastClos, i, x, colData, col, matrix <float> minMax) => \n\n    switch only\n\n        false and not hist => id.dete(lastClos, i, x, x, colData, col) \n        \n        =>       minMax.set(0, x, math.min(nz(minMax.get(0, x), 1e8 ), lastClos)), \n                 minMax.set(1, x, math.max(nz(minMax.get(1, x), -1e8), lastClos))\n\n\nmethod endTrim (array <box> histBox, array<float> val, array<float> freq, array<label> histLabs) => \n\n    if freq.size() > 0 and val.size() == freq.size() and histLabs.size() == freq.size() and histBox.size() == freq.size()\n        for i = 0 to freq.size() - 1\n            switch val.get(i) == 9e9\n                true => histBox.get(i).delete(), histLabs.get(i).delete()\n                =>      break\n\n        for i = freq.size() - 1 to 0\n            switch val.get(i) == 9e9\n                true => histBox.get(i).delete(), histLabs.get(i).delete()\n                =>      break\n// \n\nmethod returnCheck(array<float> id, array<string> id2) => \n\n    if id2.size() > 0 \n        for i = 0 to id2.size() - 1\n            if not na(str.tonumber(id2.get(i)))\n                id.push(str.tonumber(id2.get(i)))\n\nif barstate.islastconfirmedhistory \n\n    subs    = str.split(txt , \"\\n\")\n    subs1   = str.split(txt2, \"\\n\")\n    subs2   = str.split(txt3, \"\\n\")\n    subs3   = str.split(txt4, \"\\n\")\n\n    if not justPrice\n\n        ret.returnCheck(subs ), ret.returnCheck(subs1),\n        ret.returnCheck(subs2), ret.returnCheck(subs3)\n\n    sum  = switch justPrice \n\n        false => ret.sum()\n        =>       close\n\n    [row, column] = switch lab \n\n        false => [math.floor(500 / forx), forx] \n        =>       [           1000, 1          ]\n    \n\n    lines    = array.new_line()\n    minMax   = matrix.new<float>(2, forx + 1)\n    lineData = matrix.new<float>(row, column)\n    colData  = matrix.new<color>(row, column)\n\n    res = 0.\n\n    for i = 0 to sims\n\n        col = color.rgb(math.random(0, 255), math.random(0, 255), math.random(0, 255))\n\n        lastClose = sum\n\n        if not lab\n            lineData.dete(sum, i, 0, 0, colData, col)\n\n\n        for x = 1 to forx - 1\n \n            res       := distribution()\n            lineData  .iSwitch(lastClose, i, x, colData, col, minMax)\n            lastClose := lastClose.num(res)\n\n        endPoints.push(lastClose.num(res))\n        log.info(str.tostring(lastClose.num(res)))\n\n    if not hist\n\n        if only \n\n            minMax.set(0, 0, sum)\n            minMax.set(1, 0, sum)\n\n            for i = 1 to forx \n\n                line.new(bar_index + i - 1, minMax.get(0, i - 1), bar_index + i, minMax.get(0, i), color = color.red , style = finS)\n                line.new(bar_index + i - 1, minMax.get(1, i - 1), bar_index + i, minMax.get(1, i), color = color.lime, style = finS)\n\n        else \n\n            if not lab\n                for x = 0 to lineData.rows() - 1\n                    for i = 1 to lineData.columns() - 1\n\n                        modulo = i % forx\n\n                        line.new(bar_index + modulo - 1, lineData.get(x, i - 1), bar_index + modulo, lineData.get(x, i), \n                                         color = colData.get(x, i), \n                                         style = finS\n                                         )\n            else \n\n                for x = 0 to lineData.rows() - 1\n\n                    random = int(math.random(1, 250, seed))\n\n                    switch label.all.size() >= 500\n\n                        false => label.new(bar_index + random, lineData.get(x, 0), color = colData.get(x, 0), \n                                             text      = \"◉\", \n                                             style     = label.style_text_outline, \n                                             size      = size.tiny, \n                                             textcolor = chart.fg_color\n                                             )\n\n                        true  => box.new  (bar_index + random, lineData.get(x, 0), bar_index + random, lineData.get(x, 0), \n                                             text_color = colData.get(x, 0), \n                                             text       = \"◉\", \n                                             text_size  = size.tiny\n                                             )\n\n        if not justPrice\n\n            line.new  (bar_index - 1, ret.sum(), bar_index, ret.sum(), color = chart.fg_color, extend = extend.left)\n\n            label.new (bar_index - 1, ret.sum(), text = str.tostring(ret.sum()), size = size.tiny, \n\n                                 style     = label.style_label_down, \n                                 color     = #00000000, \n                                 textcolor = color.white\n                                 )\n\n    min = 1e8, max = -1e8, xmax = int(-1e8)\n\n    if not only and not hist\n\n\n        endPoint = switch lab \n\n            false => line.all .size() - 1\n            =>       label.all.size() - 1\n\n        for i = 0 to endPoint\n\n\n            switch lab\n\n                false => min := math.min(line.all .get(i).get_y2(), min),\n                         max := math.max(line.all .get(i).get_y2(), max)\n\n                =>       min  := math.min(nz(label.all.get(i).get_y (),  1e8), min ),\n                         max  := math.max(nz(label.all.get(i).get_y (), -1e8), max ), \n                         xmax := math.max(nz(label.all.get(i).get_x(), int(-1e8)), xmax)\n\n        if lab\n\n            if box.all.size() > 0 \n\n                for i = 0 to box.all.size() - 1  \n\n                    btm = box.all.get(i).get_bottom()\n                    min  := math.min(min,  nz(btm,  1e8))\n                    max  := math.max(max,  nz(btm, -1e8))\n                    xmax := math.max(xmax, nz(box.all.get(i).get_right (), int(-1e8)))\n    else \n\n        if not hist\n\n            min := minMax.min()\n            max := minMax.max()\n\n\n    if not lab and not hist\n\n        for i = 0 to forx - 1\n\n            label.new(bar_index + i, min.mult(), str.tostring(i), style = label.style_label_up, color = #00000000, textcolor = chart.fg_color, size = size.tiny)\n\n\n    if not hist\n\n        [xcoor, txtt, xcoor2] = switch lab \n\n            false => [bar_index - 2, justPrice ? \"Time #\" : \"Trade #\", bar_index + forx + 1]\n            =>       [bar_index - 4, \"All Results For \" + (justPrice ? \"Time # \" : \"Trade # \") + str.tostring(forx - 1), xmax + 5]\n\n\n        label.new(xcoor, min.mult(), text = txtt, color = #00000000, \n                             textcolor = chart.fg_color, \n                             size      = size.tiny, \n                             style     = label.style_label_up)\n\n        line.new (bar_index - 3, min.mult(), xcoor2, min.mult(), color = chart.fg_color)\n        line.new (xcoor2,        min.mult(), xcoor2, max.mult(), color = chart.fg_color)\n\n        calc = (max.mult() - min.mult()) / 10\n\n        for i = 0 to 10 \n\n            label.new(xcoor2, min.mult() + (i * calc), str.tostring(min.mult() + (i * calc), format.mintick), \n                         textcolor = chart.fg_color, \n                         style     = label.style_label_left, \n                         size      = size.tiny, \n                         color     = #00000000\n                         )\n\n\n    if not only and not lin\n \n\n        k = math.ceil(binSize(endPoints.size()))\n\n        maxR  = endPoints.max()\n        minR  = endPoints.min()\n\n        freq  = array.new_float(k, hist ? 0 : sum) \n        count = array.new_float(k, 0)\n        val   = array.new_float(k, 9e9)\n\n\n        sizE = (maxR - minR) / k \n        \n\n        for i = 0 to endPoints.size() - 1\n\n            ind = math.floor((endPoints.get(i) - minR) / sizE) \n\n            if ind >= 0 and ind < k\n\n                freq.set(ind, freq.get(ind) + 1)\n                count.set(ind, count.get(ind) + 1)\n\n                if endPoints.get(i) < val.get(ind)\n                    val.set(ind, endPoints.get(i))\n\n        newMin = 1e8, newMax = -1e8\n\n        if not hist\n\n            if not only\n\n                for i = 0 to line.all.size() - 1\n\n                    newMin := math.min(newMin, line.all.get(i).get_y2()) \n                    newMax := math.max(newMax, line.all.get(i).get_y2()) \n\n            else \n                newMin := minMax.min(), newMax := minMax.max()\n\n        else \n            newMin := close * .975, newMax := close * 1.025\n\n        if not lab \n\n            histLabs = array.new_label(), histBox = array.new_box()\n\n            if not hist\n\n                freqMin = freq.min(), freqMax = freq.max(), freqRange = freqMax - freqMin, minimum = 1e8\n\n                for i = 0 to freq.size() - 1\n\n                    freq.set(i, ((freq.get(i) - freqMin) / freqRange) * (newMax - newMin) + newMin)\n\n                    if freq.get(i) != newMin \n                        minimum := math.min(minimum, freq.get(i))\n\n                for i = 0 to freq.size() - 1 \n\n\n                    pretext = switch justPrice \n\n                        true => str.tostring((val.get(i) - close) / close, \"###.0000\") + \"\\n\" + str.tostring(count.get(i))\n                        =>      str.tostring(val.get(i), format.mintick) + \"\\n\" + str.tostring(count.get(i))\n\n\n                    strtxt = switch val.get(i) == 9e9\n                        true => \"--\" \n                        =>      pretext\n\n                    histBox.push(box.new(bar_index   + forx + 6 + i, newMin, bar_index + forx + 6 + i + 1, math.max(freq.get(i), minimum), \n                                                 bgcolor = color.new(#6929F2, 50), \n                                                 border_color = chart.fg_color\n                                                 ))\n\n                    histLabs.push(label.new(bar_index + forx + 6 + i, newMin, \"   \" + strtxt, \n                                                 style     = label.style_label_up, \n                                                 color     = #00000000, \n                                                 textcolor = chart.fg_color, \n                                                 size      = size.tiny))\n\n                    histBox.endTrim(val, freq, histLabs)\n\n            else \n\n                for i = 0 to freq.size() - 1 \n\n                    pretext = switch justPrice\n                        \n                        true => str.tostring((val.get(i) - close) / close, \"###.0000\") + \"\\n\" + str.tostring(count.get(i))\n                        =>      str.tostring(val.get(i), format.mintick) + \"\\n\" + str.tostring(count.get(i))\n                    \n                    strtxt = switch val.get(i) == 9e9\n\n                        true => \"--\" \n                        =>      pretext\n\n\n                    histBox.push(box.new(bar_index - 20 + i , 0, bar_index - 20 + i + 1, math.max(freq.get(i), 0.2), \n                                     bgcolor      = color.new(#6929F2, 50), \n                                     border_color = chart.fg_color))\n\n\n\n                    histLabs.push(label.new(bar_index - 20 + i, 0,\n                          \"   \" + strtxt, \n                                         style     = label.style_label_up, \n                                         color     = #00000000, \n                                         textcolor = chart.fg_color, \n                                         size      = size.tiny\n                                         ))\n\n                    histBox.endTrim(val, freq, histLabs)\n\n\n            [yloc1, yloc2] = switch hist\n                \n                false => [newMin, newMax]\n                =>       [0, freq.max()]\n\n            xloc  = box.all.last ().get_right() + 2\n            xloc1 = box.all.first().get_left()\n\n            line.new(xloc , yloc1, xloc, yloc2, color = chart.fg_color)\n            line.new(xloc1, yloc1, xloc, yloc1, color = chart.fg_color)\n\n            calc = ((count.max() / count.sum() * 100) - (count.min() / count.sum() * 100)) / 10\n            calcy = (yloc2 - yloc1) / 10\n            label.new(xloc1 - 1, yloc1, \"Return\\nCount\", style = label.style_label_up, color = #00000000, textcolor = chart.fg_color, size = size.tiny)\n            \n            for i = 0 to 10 \n\n                label.new(xloc, yloc1 + (calcy * i), text = str.tostring(count.min() + (calc * i), format.percent), \n\n                                 style     = label.style_label_left,\n                                 color     = #00000000, \n                                 textcolor = chart.fg_color,\n                                 size      = size.tiny\n                                 )\n\n            highest = count.indexof(count.max())\n\n            if not lab and not lin\n\n                for i = 1 to count.size() - 1\n    \n                    slice = count.slice(highest - i, highest + i + 1)\n    \n                    if slice.sum() / count.sum() >= cumu \n                    \n                        for x = highest - i to highest + i\n                            histBox.get(x).set_bgcolor(color.new(#6929F2, 50)) \n                        \n                        label.new(\n                                 math.round(\n                                     math.avg(\n                                         histBox.get(highest).get_left(), histBox.get(highest).get_right())), histBox.get(highest).get_bottom(), \n                                         text = \"Cumulative Prob: \" + str.tostring(slice.sum() / count.sum() * 100, format.percent), \n                                         color = #00000000, textcolor = #6929F2, size = size.tiny)\n    \n                        left  = histBox.get(highest - i)\n                        right = histBox.get(highest + i)\n                        top   = histBox.get(highest)\n    \n                        l = line.new(left.get_left(), top.get_top(), left.get_left(), top.get_bottom()    , color = #00000000)\n                        r = line.new(right.get_right(), top.get_top(), right.get_right(), top.get_bottom(), color = #00000000)\n                        linefill.new(l, r, color.new(chart.fg_color, 75))\n    \n                        break\n\nfloatna () => \n\n    [float(na), float(na), float(na), float(na), color(na)]\n\n[o, h, l, c, color] = switch justPrice \n\n    false =>             floatna()\n    true and not hist => [open, high, low, close, close > open ? color.aqua : color.red]\n    =>                   floatna()\n    \nplotcandle(o, h, l, c, color = color, wickcolor = color, bordercolor = chart.fg_color, display = display.pane)\n\n// ","updated":"2023-09-29T01:11:01.801002Z","version":"3.0"}