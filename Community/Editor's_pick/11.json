{"created":"2024-04-17T16:53:26.770043Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"2.0","scriptAccess":"open_no_auth","scriptName":"Periodic Activity Tracker [LuxAlgo]","source":"// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/\r\n// © LuxAlgo\r\n\r\n//@version=5\r\nindicator('Periodic Activity Tracker [LuxAlgo]', 'LuxAlgo - Periodic Activity Tracker')\r\n//---------------------------------------------------------------------------------------------------------------------}\r\n//CONSTANTS & STRINGS & INPUTS\r\n//---------------------------------------------------------------------------------------------------------------------{\r\nHOURLY                  = 'HOURLY'\r\nDAILY                   = 'DAILY'\r\nWEEKLY                  = 'WEEKLY'\r\nMONTHLY                 = 'MONTHLY'\r\n\r\nGREEN                   = #089981\r\nRED                     = #F23645\r\nTEAL                    = color.new(color.teal, 80)\r\nGRAY                    = color.new(color.gray, 80)\r\n\r\nDATA_GROUP              = 'Data gathering'\r\nSTYLE_GROUP             = 'Style'\r\n\r\nanchoringPeriodTooltip  = 'Time period representing each bar: hours of the day, days of the week, weeks of the month and months of the year. The timeframe of the chart must be less than this parameter, otherwise a warning will be displayed.'\r\nbarWidthTooltip         = 'Size of each bar, there is a maximum limit so a warning will be displayed if it is reached.'\r\nshowDeltaTooltip        = 'Enable/Disable Delta Area Display.'\r\n\r\nanchoringPeriodInput    = input.string( DAILY, 'Anchor period',    tooltip = anchoringPeriodTooltip,   group = DATA_GROUP,     options = [HOURLY,DAILY,WEEKLY,MONTHLY])\r\nbarWidthInput           = input.int(    2,      'Bar width',        tooltip = barWidthTooltip,          group = STYLE_GROUP,    minval  = 2)\r\nbuyColorInput           = input.color(  GREEN,  'Volume color',     tooltip = '',                       group = STYLE_GROUP,    inline = '1')\r\nsellColorInput          = input.color(  RED,    '',                 tooltip = '',                       group = STYLE_GROUP,    inline = '1')\r\nshowDeltaInput          = input.bool(   true,   'Delta  ',          tooltip = showDeltaTooltip,         group = STYLE_GROUP,    inline = '2')\r\npositiveDeltaColorInput = input.color(  TEAL,   '',                 tooltip = '',                       group = STYLE_GROUP,    inline = '2')\r\nnegativeDeltaColorInput = input.color(  GRAY,   '',                 tooltip = '',                       group = STYLE_GROUP,    inline = '2')\r\n \r\n//---------------------------------------------------------------------------------------------------------------------}\r\n//DATA STRUCTURES & VARIABLES\r\n//---------------------------------------------------------------------------------------------------------------------{\r\n// @variable    Get chart timeframe in minutes to compare to next variable\r\nvar chartTimeframeInMinutes = timeframe.in_seconds() / 60\r\n\r\n// @variable    Check if the user has selected an incorrect chart timeframe match for the 'Anchor period' parameter\r\nvar bool wrongTimeframe     = switch anchoringPeriodInput\r\n    HOURLY      =>  chartTimeframeInMinutes >= 60\r\n    DAILY       =>  chartTimeframeInMinutes >= 60 * 24\r\n    WEEKLY      =>  chartTimeframeInMinutes >= 60 * 24 * 7 \r\n    MONTHLY     =>  chartTimeframeInMinutes >= 60 * 24 * 30\r\n\r\n// @type        Storage UDT for each period bar\r\n// @field buy   (float) Buy volume\r\n// @field sell  (float) Sell volume\r\n// @field tag   (string) Tag identifying the bar, such as MON for Monday or JAN for January\r\ntype barVolume\r\n    float buy   = 0\r\n    float sell  = 0\r\n    string tag  = ''\r\n\r\n// @variable    Storage array for `barVolume` UDTs\r\nvar array<barVolume> bars = array.new<barVolume>()\r\n\r\n//---------------------------------------------------------------------------------------------------------------------}\r\n//USER-DEFINED FUNCTIONS\r\n//---------------------------------------------------------------------------------------------------------------------{\r\n// @function        Draw a table with custom text\r\n// @param message   (string) Text to display\r\n// @returns         void\r\nshowInfoPanel(string message) =>\r\n    var table t_able = table.new(position.top_center, 1, 1)\r\n    table.cell(t_able, 0, 0, message, text_color = chart.fg_color)\r\n\r\n// @function        Get day of week as text from `time`\r\n// @param bar_time (int) Milliseconds from 1970\r\n// @param isCrypto (bool) Check if the ticker is crypto\r\n// @returns         string\r\ngetDayofweek(int bar_time, bool isCrypto = false) =>\r\n    if isCrypto\r\n        switch dayofweek(bar_time)\r\n            1   => 'SUN'\r\n            2   => 'MON'\r\n            3   => 'TUE'\r\n            4   => 'WED'\r\n            5   => 'THU'\r\n            6   => 'FRI'\r\n            7   => 'SAT'\r\n    else\r\n        switch dayofweek(bar_time)\r\n            1   => 'MON'\r\n            2   => 'TUE'\r\n            3   => 'WED'\r\n            4   => 'THU'\r\n            5   => 'FRI'\r\n\r\n// @function        Get week of the month as string\r\n// @returns         string\r\ngetWeek() => str.tostring(array.size(bars) + 1)\r\n\r\n// @function        Get month as string\r\n// @param           (int)\r\n// @returns         string\r\ngetMonth(int bar_time) =>    \r\n    switch month(bar_time)\r\n        1   => 'JAN'\r\n        2   => 'FEB'\r\n        3   => 'MAR'\r\n        4   => 'APR'\r\n        5   => 'MAY'\r\n        6   => 'JUN'\r\n        7   => 'JUL'\r\n        8   => 'AUG'\r\n        9   => 'SEP'\r\n        10  => 'OCT'\r\n        11  => 'NOV'\r\n        12  => 'DEC'\r\n\r\n// @function        Volume of bullish candle\r\n// @returns         float\r\nbuyVolume() => close > open ? volume : 0\r\n\r\n// @function        Volume of bearish candle\r\n// @returns         float\r\nsellVolume() => close < open ? volume : 0\r\n\r\n// @function        Get tag parameter for bar as hour of day, day of week, week of month or month of year\r\n// @returns         string\r\nbarTag() =>\r\n    switch anchoringPeriodInput\r\n        HOURLY      =>  str.tostring(hour(time))\r\n        DAILY       =>  getDayofweek(time_tradingday, syminfo.type == 'crypto')\r\n        WEEKLY      =>  getWeek()\r\n        MONTHLY     =>  getMonth(time_close)\r\n\r\n// @function        Create a new `barVolume` and store it in the array\r\n// @returns         void\r\ncreateNewBar() => array.push(bars, barVolume.new(buyVolume(), sellVolume(), barTag()))\r\n\r\n// @function        Update volume on last `barVolume` object\r\n// @returns         float\r\nupdateLastBar() =>\r\n    size = array.size(bars)\r\n    if size > 0\r\n        barVolume lastBar   = array.get(bars, size-1)\r\n        lastBar.buy         += buyVolume()\r\n        lastBar.sell        += sellVolume()\r\n\r\n// @function        Get buy and sell volume values from the last `barVolume` object\r\n// @returns         float tuple\r\ngetLastValues() =>\r\n    size = array.size(bars)\r\n    if size > 0\r\n        barVolume lastBar = array.get(bars,size-1)\r\n        [lastBar.buy,lastBar.sell]\r\n    else\r\n        [na,na]\r\n\r\n// @function        Draw two boxes and a label for each `barVolume` object (sell volume, buy volume and bar tag)\r\n// @returns         last label ID\r\nplotBars() =>    \r\n    for eachBox in box.all\r\n        box.delete(eachBox)\r\n    for eachLabel in label.all\r\n        label.delete(eachLabel)\r\n    \r\n    // PineScript has a limit of 500 bars beyond last_bar_index for drawings using xloc.bar_index\r\n    // So we get the rightmost bar_index and then check if it is less than or equal to 500.\r\n    rightMostIndex = 4 * barWidthInput + (array.size(bars) - 1) * (3 * barWidthInput)\r\n\r\n    // We are within the parameters, so we continue the execution and draw the boxes and labels.\r\n    if rightMostIndex <= 500\r\n\r\n        for [index,eachBar] in bars\r\n                        \r\n            leftIndex           = 2 * barWidthInput + index * (3 * barWidthInput)\r\n\r\n            topLeftPoint1       = chart.point.new(na,   last_bar_index + leftIndex,                             eachBar.sell)\r\n            bottomRightPoint1   = chart.point.new(na,   last_bar_index + leftIndex + barWidthInput,             0)\r\n\r\n            topLeftPoint2       = chart.point.new(na,   last_bar_index + leftIndex + barWidthInput,             eachBar.buy)\r\n            bottomRightPoint2   = chart.point.new(na,   last_bar_index + leftIndex + barWidthInput * 2,         0)\r\n\r\n            labelPoint          = chart.point.new(na,   last_bar_index + leftIndex + barWidthInput,             0)\r\n\r\n            box.new(    topLeftPoint1,  bottomRightPoint1,  border_width    = 0,            bgcolor     = sellColorInput)\r\n            box.new(    topLeftPoint2,  bottomRightPoint2,  border_width    = 0,            bgcolor     = buyColorInput)\r\n            label.new(  labelPoint,     eachBar.tag,        color           = color(na),    textcolor   = chart.fg_color,   style = label.style_label_up)\r\n\r\n    // Instead of having the runtime environment throw an error, we display a custom message.\r\n    else\r\n        showInfoPanel('Oops... The `Bar width` parameter is much too large.\\nChoose a smaller parameter.')\r\n        na\r\n\r\n// @function        Update the height of the last two boxes drawn with volume values from the last `barVolume` object\r\n// @returns         void\r\nupdateLastPlottedBar() =>\r\n    [buyVolume,sellVolume] = getLastValues()\r\n    \r\n    size    = array.size(box.all)\r\n    if size >= 2\r\n\r\n        box lastBuyVolumeBar    = array.get(box.all, size - 1)\r\n        box lastSellVolumeBar   = array.get(box.all, size - 2)\r\n        \r\n        box.set_top(    lastSellVolumeBar,  sellVolume)\r\n        box.set_top(    lastBuyVolumeBar,   buyVolume)\r\n\r\n//---------------------------------------------------------------------------------------------------------------------}\r\n//MUTABLE VARIABLES & EXECUTION\r\n//---------------------------------------------------------------------------------------------------------------------{\r\n// @variable        Check if the current bar is the start of a new period (aka `barVolume` object)\r\nbool newPeriod = switch anchoringPeriodInput\r\n    HOURLY      => ta.change(hour)          != 0 \r\n    DAILY       => ta.change(dayofmonth)    != 0 \r\n    WEEKLY      => ta.change(weekofyear)    != 0 \r\n    MONTHLY     => ta.change(month)         != 0 \r\n\r\n// @variable        Check if the current bar is the start of a new set of `barVolume` objects\r\nbool newBarSet = switch anchoringPeriodInput\r\n    HOURLY      => ta.change(dayofmonth)    != 0 \r\n    DAILY       => ta.change(weekofyear)    != 0\r\n    WEEKLY      => ta.change(month)         != 0\r\n    MONTHLY     => ta.change(month)         != 0 and month == 1\r\n\r\n// If the user has selected a chart timeframe equal to or greater than the 'Anchor Period' parameter, a message will be displayed.\r\nif wrongTimeframe\r\n    showInfoPanel('Oops... The chart timeframe must be smaller than the `Anchor period` parameter.\\nSelect a smaller chart timeframe or a larger `Anchor period` parameter.')\r\n\r\n// If the chart timeframe is a valid one, we will continue the execution.\r\nelse    \r\n    if newPeriod\r\n        createNewBar()\r\n    else    \r\n        updateLastBar()\r\n\r\n    if newBarSet\r\n        array.clear(bars)\r\n        \r\n        // This createNewBar() call is here to store a new weekly bar at the start of each new month, for the rest of the periods it does not matter because they are the same: \r\n        // each new day is the start of a new hour, each new week is the start of a new day, each new year is the start of a new month, but each new month is not the start of a new week.        \r\n        createNewBar()\r\n    \r\n    if barstate.islastconfirmedhistory or (barstate.isrealtime and barstate.isconfirmed)\r\n        plotBars()\r\n    if barstate.isrealtime\r\n        updateLastPlottedBar()\r\n\r\n// We get current volume values to plot as lines\r\n[buyVolume,sellVolume] = getLastValues()\r\n\r\n// We plot the buy and sell volumes with a break effect between the periods provided by setting the colour to 'na' on the first bar of a new period or a new set of periods (bars).\r\nbuyVolumePlot   = plot(not wrongTimeframe ? buyVolume  : na, '', newBarSet or newPeriod ? color(na) : buyColorInput)\r\nsellVolumePlot  = plot(not wrongTimeframe ? sellVolume : na, '', newBarSet or newPeriod ? color(na) : sellColorInput)\r\n\r\n// Gradient fill between the two plots\r\nfill(buyVolumePlot, sellVolumePlot, math.max(buyVolume, sellVolume), math.min(buyVolume, sellVolume), newBarSet or newPeriod ? color(na) : buyVolume > sellVolume ? color.new(GREEN, 50) : color.new(RED, 50), color.new(chart.bg_color, 100))\r\n\r\n// We plot the delta between the volumes as an area.\r\nplot(showDeltaInput ? (buyVolume - sellVolume) / 2 : na, style = plot.style_area, color = newBarSet or newPeriod ? color(na) : buyVolume > sellVolume ? positiveDeltaColorInput : negativeDeltaColorInput)\r\n\r\n// Separation between plots and bars for real-time execution\r\nbgcolor(wrongTimeframe ? na : barstate.islast and not barstate.isconfirmed ? chart.fg_color : na, barWidthInput - 1)\r\n\r\n//---------------------------------------------------------------------------------------------------------------------}","updated":"2024-04-17T16:53:26.770043Z","version":"2.0"}