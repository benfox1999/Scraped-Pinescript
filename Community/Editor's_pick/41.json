{"created":"2023-10-02T13:50:36.031986Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"4.0","scriptAccess":"open_no_auth","scriptName":"ABC on Recursive Zigzag [Trendoscope]","source":"// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/\n// © Trendoscope Pty Ltd\n//                                       ░▒             \n//                                  ▒▒▒   ▒▒      \n//                              ▒▒▒▒▒     ▒▒      \n//                      ▒▒▒▒▒▒▒░     ▒     ▒▒          \n//                  ▒▒▒▒▒▒           ▒     ▒▒          \n//             ▓▒▒▒       ▒        ▒▒▒▒▒▒▒▒▒▒▒  \n//   ▒▒▒▒▒▒▒▒▒▒▒ ▒        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒         \n//   ▒  ▒       ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░        \n//   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒         \n//   ▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ ▒▒                       \n//    ▒▒▒▒▒         ▒▒▒▒▒▒▒                            \n//                 ▒▒▒▒▒▒▒▒▒                           \n//                ▒▒▒▒▒ ▒▒▒▒▒                          \n//               ░▒▒▒▒   ▒▒▒▒▓      ████████╗██████╗ ███████╗███╗   ██╗██████╗  ██████╗ ███████╗ ██████╗ ██████╗ ██████╗ ███████╗\n//              ▓▒▒▒▒     ▒▒▒▒      ╚══██╔══╝██╔══██╗██╔════╝████╗  ██║██╔══██╗██╔═══██╗██╔════╝██╔════╝██╔═══██╗██╔══██╗██╔════╝\n//              ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒        ██║   ██████╔╝█████╗  ██╔██╗ ██║██║  ██║██║   ██║███████╗██║     ██║   ██║██████╔╝█████╗ \n//             ▒▒▒▒▒       ▒▒▒▒▒       ██║   ██╔══██╗██╔══╝  ██║╚██╗██║██║  ██║██║   ██║╚════██║██║     ██║   ██║██╔═══╝ ██╔══╝  \n//            ▒▒▒▒▒         ▒▒▒▒▒      ██║   ██║  ██║███████╗██║ ╚████║██████╔╝╚██████╔╝███████║╚██████╗╚██████╔╝██║     ███████╗\n//             ▒▒             ▒                        \n//@version=5\nimport HeWhoMustNotBeNamed/DrawingTypes/2 as dr\nimport HeWhoMustNotBeNamed/DrawingMethods/2\nimport HeWhoMustNotBeNamed/ZigzagTypes/5 as zg\nimport HeWhoMustNotBeNamed/ZigzagMethods/6\n\nimport HeWhoMustNotBeNamed/utils/1 as ut\n\nimport HeWhoMustNotBeNamed/FibRatios/1 as fibs\n\nindicator(\"ABC on Recursive Zigzag [Trendoscope]\", \"ABC-RZ[Trendoscope]\", overlay = true, max_lines_count=500, max_labels_count=500, max_bars_back = 1000)\ntheme = input.string('Dark', title='Theme', options=['Light', 'Dark'], group='Generic Settings',\n         tooltip='Chart theme settings. Line and label colors are generted based on the theme settings. If dark theme is selected, '+\n         'lighter colors are used and if light theme is selected, darker colors are used.', display=display.none)\n\nzigzagLength = input.int(13, step=5, minval=3, title='Length', group='Zigzag', tooltip='Zigzag length for level 0 zigzag', display = display.none)\ndepth = input.int(200, \"Depth\", step=25, maxval=500, group='Zigzag', tooltip='Zigzag depth refers to max number of pivots to show on chart', display = display.none)\nminimumZigZagLevel = input.int(0, \"Minimum Zigzag Level\", group='Zigzag', minval = 0, tooltip = 'Minimum zigzag level to consider for pattern scanning', display=display.none)\n\nindicators = matrix.new<float>()\nindicatorNames = array.new<string>()\n\nbase = input.string('ABC Extension', 'Base', ['ABC Extension', 'BC Retracement'], 'Base on which entry, stop and target are calculated', group='ABC', display = display.none)\nentryRatio = input.float(0.3, 'Entry Ratio', group='ABC', minval=0.1, step=0.1, display = display.none, tooltip = 'Entry ratio for the calculation of entry level')\ntargetRatio = input.float(1.0, 'Target Ratio', group='ABC', display = display.none, tooltip = 'Target Ratio for the calculation of target level')\nstopRatio = input.float(0.0, 'Stop Ratio', group='ABC', maxval=0.0, step=0.1, display = display.none, tooltip = 'Stop Ratio for the calculation of stop level')\nlogScale = input.bool(false, 'Log Scale', group='ABC', display = display.none, tooltip = 'Use log scale for scanning and targets')\nuseClosePricesForEntry = input.bool(true, 'Entry', group='Use Close Prices', display = display.none, tooltip = 'Use close prices for tracking', inline = 'ucp')\nuseClosePricesForTarget = input.bool(true, 'Target', group='Use Close Prices', display = display.none, tooltip = 'Use close prices for tracking', inline = 'ucp')\nuseClosePricesForStop = input.bool(true, 'Stop', group='Use Close Prices', display = display.none, tooltip = 'Use close prices for tracking', inline = 'ucp')\nuseClosePricesForRetest = input.bool(true, 'Retest', group='Use Close Prices', display = display.none, tooltip = 'Use close prices for tracking', inline = 'ucp')\n\ntradeConditionTooltip = 'any - no filter\\ntrend - Both A and B pivots in the direction of trend. Example, HH, and HL for long signal and LH and LL for short signal\\n'+\n                             'reverse - Both A and B pivots in the opposite direction of trend. Example, LH, and LL for long signal and HH and HL for short signal\\n'+\n                             'contracting - Consider only if both A and B pivots are either LH or HL\\nexpanding - Consider only if both A and B pivots are either HH or LL'\n\ntradeCondition = input.string('any', 'Trade Condition', ['any', 'trend', 'reverse', 'contracting', 'expanding'], group='ABC', display = display.none, tooltip = tradeConditionTooltip)\n\ncondition = tradeCondition == 'any'? 0:\n                 tradeCondition == 'trend'? 1:\n                 tradeCondition == 'reverse'? 2:\n                 tradeCondition == 'contracting'? 3: 4\n\nbaseVal = base == 'ABC Extension'? 1 : 2\n\n\nvar zg.Zigzag zigzag = zg.Zigzag.new(zigzagLength, depth)\nzigzag.calculate(array.from(high, low), indicators, indicatorNames)\n\ntype ABCProperties\n    int base = 1\n    float entryRatio = 0.23\n    float targetRatio = 1.0\n    float stopRatio = -0.1\n    bool logScale = false\n    bool useClosePricesForEntry = true\n    bool useClosePricesForTarget = false\n    bool useClosePricesForStop = true\n    bool useClosePricesForRetest = false\n    int condition = 0\n\ntype ABCDrawing\n    dr.Line ab\n    dr.Line bc\n    dr.Line ac\n    dr.Label a\n    dr.Label b\n    dr.Label c\n    dr.Label abcRatio\n    dr.Box entryBox\n    dr.Box targetBox\n\ntype ABC\n    int id\n    int direction\n    zg.Pivot a\n    zg.Pivot b\n    zg.Pivot c\n    color patternColor\n    ABCProperties properties\n    float entryPrice\n    float stopPrice\n    float targetPrice\n    int status = 0\n    ABCDrawing drawing\n\ninitialiseCounts(int numberOfStatus)=>\n    countMap = map.new<int, int>()\n    for i=0 to numberOfStatus-1\n        countMap.put(i, 0)\n    countMap\n\nvar array<ABC> abcdPatterns = array.new<ABC>()\nvar array<ABC> oldPatterns = array.new<ABC>()\n\nvar map<int, int> bullishCounts = initialiseCounts(3)\nvar map<int, int> bearishCounts = initialiseCounts(3)\n\nvar int bullishRetests = 0\nvar int bearishRetests = 0\n\nmethod calculateTargets(ABC this)=>\n    this.entryPrice := this.properties.base == 1 ?\n         fibs.extension(this.a.point.price, this.b.point.price, this.c.point.price, this.properties.entryRatio, this.properties.logScale) :\n         fibs.retracement(this.b.point.price, this.c.point.price, this.properties.entryRatio, this.properties.logScale)\n\n    this.targetPrice := this.properties.base == 1 ?\n         fibs.extension(this.a.point.price, this.b.point.price, this.c.point.price, this.properties.targetRatio, this.properties.logScale) :\n         fibs.retracement(this.b.point.price, this.c.point.price, this.properties.targetRatio, this.properties.logScale)\n\n    this.stopPrice := this.properties.base == 1 ?\n         fibs.extension(this.a.point.price, this.b.point.price, this.c.point.price, this.properties.stopRatio, this.properties.logScale) :\n         fibs.retracement(this.b.point.price, this.c.point.price, this.properties.stopRatio, this.properties.logScale)\n    this\n\nmethod withinEntry(ABC this)=>\n    dir = this.c.point.price > this.b.point.price? -1 : 1\n    close*dir < this.entryPrice*dir\n\nmethod delete(ABCDrawing this)=>\n    if(not na(this))\n        this.ab.delete()\n        this.bc.delete()\n        this.ac.delete()\n        this.abcRatio.delete()\n        this.a.delete()\n        this.b.delete()\n        this.c.delete()\n        this.entryBox.delete()\n        this.targetBox.delete()\n    else\n        log.info('this should not be na')\n    this\n\nmethod draw(ABCDrawing this)=>\n    if(not na(this))\n        this.ab.draw()\n        this.bc.draw()\n        this.ac.draw()\n        this.abcRatio.draw()\n        this.a.draw()\n        this.b.draw()\n        this.c.draw()\n        this.entryBox.draw()\n        this.targetBox.draw()\n    else\n        log.info('this should not be na')\n    this\n\nmethod draw(ABC this)=>\n    this.drawing.draw()\n    this\n\nmethod deleteDrawing(ABC this)=>\n    if(not na(this.drawing))\n        this.drawing.delete()\n        this.drawing := na\n    this\n\nmethod createDrawing(ABC this)=>\n    if(not na(this.drawing))\n        this.drawing.delete()\n\n    dr.LineProperties patternLineProps = dr.LineProperties.new(color=this.patternColor, width = 1, style = line.style_solid)\n    ab = this.a.point.createLine(this.b.point, patternLineProps)\n    bc = this.b.point.createLine(this.c.point, patternLineProps)\n    dr.LineProperties angleLineProps = dr.LineProperties.new(color=this.patternColor, width = 0, style = line.style_dotted)\n    ac = dr.Line.new(this.a.point, this.c.point, angleLineProps)\n    acMidPoint = dr.Point.new((this.a.point.price+this.c.point.price)/2, (this.a.point.bar + this.c.point.bar)/2, (this.a.point.bartime + this.c.point.bartime)/2)\n    abcRatioValue = fibs.retracementRatio(this.a.point.price, this.b.point.price, this.c.point.price)\n    ratioLabelProperties = dr.LabelProperties.new(yloc = yloc.price, textcolor = this.patternColor, style = label.style_none)\n    abcRatio = dr.Label.new(acMidPoint, str.tostring(abcRatioValue), properties = ratioLabelProperties)\n    pivotLabelPropertiesAC = dr.LabelProperties.new(yloc = this.a.point.price < this.b.point.price? yloc.belowbar : yloc.abovebar, textcolor = this.patternColor)\n    pivotLabelPropertiesBD = dr.LabelProperties.new(yloc = this.a.point.price > this.b.point.price? yloc.belowbar : yloc.abovebar, textcolor = this.patternColor)\n    a = dr.Label.new(this.a.point, 'A', properties = pivotLabelPropertiesAC)\n    b = dr.Label.new(this.b.point, 'B', properties = pivotLabelPropertiesBD)\n    c = dr.Label.new(this.c.point, 'C', properties = pivotLabelPropertiesAC)\n\n    entryPoint = dr.Point.new(this.entryPrice, this.c.point.bar, this.c.point.bartime)\n    barDiff = math.min((this.c.point.bar- this.a.point.bar)/2, 490)\n\n    entryBoxEndPoint = dr.Point.new(this.stopPrice, this.c.point.bar+barDiff)\n    targetBoxEndPoint = dr.Point.new(this.targetPrice, this.c.point.bar+barDiff)\n\n    boxPropertiesEntry = dr.BoxProperties.new(this.patternColor, color.new(color.red, 90))\n    boxPropertiesTarget = dr.BoxProperties.new(this.patternColor, color.new(color.green, 90))\n    entryBox = dr.Box.new(entryPoint, entryBoxEndPoint, boxPropertiesEntry)\n    targetBox = dr.Box.new(entryPoint, targetBoxEndPoint, boxPropertiesTarget)\n    this.drawing := ABCDrawing.new(ab, bc, ac, a, b, c, abcRatio, entryBox, targetBox)\n    this\n\n\nmethod update(ABC this, zg.Pivot c)=>\n    this.c := c\n    alert('ABC Pattern Coordinates Updated')\n    this.calculateTargets()\n\n    if(this.withinEntry())\n        this.deleteDrawing().\n                 createDrawing().\n                 draw()\n    this\n    \nmethod createAbc(zg.Zigzag this, ABCProperties props, color patternColor)=>\n    var id = 1\n    c = this.zigzagPivots.get(0)\n    b = this.zigzagPivots.get(1)\n    a = this.zigzagPivots.get(2)\n    direction = b.point.price > c.point.price? 1 : -1\n    abc = ABC.new(id, direction, a, b, c, patternColor, props)\n    id+=1\n    abc\n\nmethod scanAbc(zg.Zigzag this, ABCProperties props)=>\n    isAbc = false\n            \n    if(this.zigzagPivots.size() >= 4)\n        c = this.zigzagPivots.get(0)\n        b = this.zigzagPivots.get(1)\n        a = this.zigzagPivots.get(2)\n        aDir = math.abs(a.dir)\n        bDir = math.abs(b.dir)\n        conditionInLine = props.condition == 0 or\n                             (props.condition == 1 and aDir == 1 and bDir == 2) or\n                             (props.condition == 2 and aDir == 2 and bDir == 1) or\n                             (props.condition == 3 and aDir == 1 and bDir == 1) or\n                             (props.condition == 4 and aDir == 2 and bDir == 2)\n        ratioInLine = c.ratio >= 0.618 and c.ratio <= 0.786\n        if(ratioInLine and conditionInLine)\n            existingPattern = false\n            isAbc := true\n            for p in abcdPatterns\n                existingPattern := p.a.point.price == a.point.price and p.b.point.price == b.point.price\n                if(existingPattern)\n                    if(p.c.point.bar > c.point.bar and p.status == 0)\n                        p.update(c)\n                    \n                    isAbc:=false\n                    break\n    isAbc\n\nmethod record(ABC pattern)=>\n    countMapToSet = pattern.direction >0? bullishCounts : bearishCounts\n    countMapToSet.put(pattern.status, countMapToSet.get(pattern.status)+1)\n\nmethod removePattern(array<ABC> patterns, int index)=>\n    pattern = patterns.remove(index)\n    pattern.deleteDrawing()\n    pattern.record()\n    \nmethod traverse(array<ABC> patterns)=>\n    for i = patterns.size() >0? patterns.size()-1: na to 0\n        pattern = patterns.get(i)\n        baseTarget = pattern.properties.useClosePricesForTarget? close : (pattern.direction > 0? high : low)\n        baseStop = pattern.properties.useClosePricesForStop? close : (pattern.direction >0? low : high)\n        baseEntry = pattern.properties.useClosePricesForEntry? close : (pattern.direction > 0? high : low)\n        baseValueRetest = pattern.properties.useClosePricesForRetest? close : (pattern.direction > 0? low : high)\n        baseInvalidation = close\n        newStatus = baseTarget*pattern.direction >= pattern.targetPrice*pattern.direction? 2 :\n                         baseEntry*pattern.direction >= pattern.entryPrice*pattern.direction? 1: pattern.status\n        retested = pattern.status == 1 and baseValueRetest <= pattern.entryPrice\n\n        newStatus := math.max(pattern.status, newStatus)\n        closed = (newStatus > 0 and baseStop*pattern.direction <= pattern.stopPrice*pattern.direction) or\n             (newStatus == 0 and baseInvalidation*pattern.direction <= pattern.stopPrice*pattern.direction) or\n             pattern.status == 2\n        increment = newStatus >= pattern.status\n        pattern.status := newStatus\n        if(closed)\n            patterns.removePattern(i)\n\nvar properties = ABCProperties.new(baseVal, entryRatio, targetRatio, stopRatio, logScale, useClosePricesForEntry, useClosePricesForTarget, useClosePricesForStop, useClosePricesForRetest, condition)\nvar themeColors = ut.getColors(theme)\n\nabcdPatterns.traverse()\noldPatterns.traverse()\n\nif zigzag.flags.newPivot\n    mlzigzag = zigzag\n    while(mlzigzag.zigzagPivots.size() >= 3)\n        if(mlzigzag.level >= minimumZigZagLevel)\n            isAbcd = mlzigzag.scanAbc(properties)\n            if(isAbcd)\n                patternColor = themeColors.shift()\n                alert('New ABC Pattern Detected')\n                pattern = mlzigzag.createAbc(properties, patternColor).calculateTargets()\n                if(pattern.withinEntry())\n                    pattern.createDrawing().draw()\n                    abcdPatterns.push(pattern)\n                    while(abcdPatterns.size() > 10)\n                        last = abcdPatterns.shift()\n                        oldPatterns.push(last)\n                        last.deleteDrawing()\n\n                themeColors.push(patternColor)\n        mlzigzag := mlzigzag.nextlevel()\n\nwhile(abcdPatterns.size() < 10 and oldPatterns.size() > 0)\n    restoreOld = oldPatterns.pop()\n    abcdPatterns.unshift(restoreOld)\n    restoreOld.draw()\n\nif barstate.islast\n    var closedStatsTable = table.new(position.top_right, 6, 3, border_color = chart.bg_color)\n    closedStatsTable.clear(0, 0, 5, 2)\n    closedStatsTable.cell(0, 0, 'Direction\\\\Status', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(1, 0, 'Invalid', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(2, 0, 'Stopped', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(3, 0, 'Complete', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(4, 0, 'Win Ratio', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(5, 0, 'Risk Reward', text_color=color.white, bgcolor = color.maroon)\n    closedStatsTable.cell(0, 1, 'Bullish', text_color=color.white, bgcolor = color.new(color.green, 50))\n    closedStatsTable.cell(0, 2, 'Bearish', text_color=color.white, bgcolor = color.new(color.red, 50))\n\n    bullishInvalid = bullishCounts.get(0)\n    bullishStopped = bullishCounts.get(1)\n    bullishCompleted = bullishCounts.get(2)\n    riskReward =(targetRatio - entryRatio)/(entryRatio - stopRatio)\n    bullishBgColor = color.new(color.green, 70)\n    closedStatsTable.cell(1, 1, str.tostring(bullishInvalid), text_color=color.white, bgcolor = bullishBgColor)\n    closedStatsTable.cell(2, 1, str.tostring(bullishStopped), text_color=color.white, bgcolor = bullishBgColor)\n    closedStatsTable.cell(3, 1, str.tostring(bullishCompleted), text_color=color.white, bgcolor = bullishBgColor)\n    closedStatsTable.cell(4, 1, str.tostring(bullishCompleted*100/(bullishCompleted+bullishStopped), format.percent), text_color=color.white, bgcolor = bullishBgColor)\n    closedStatsTable.cell(5, 1, str.tostring(riskReward, '#.##'), text_color=color.white, bgcolor = bullishBgColor)\n\n    bearishInvalid = bearishCounts.get(0)\n    bearishStopped = bearishCounts.get(1)\n    bearishCompleted = bearishCounts.get(2)\n    bearishBgColor = color.new(color.red, 70)\n    closedStatsTable.cell(1, 2, str.tostring(bearishInvalid), text_color=color.white, bgcolor = bearishBgColor)\n    closedStatsTable.cell(2, 2, str.tostring(bearishStopped), text_color=color.white, bgcolor = bearishBgColor)\n    closedStatsTable.cell(3, 2, str.tostring(bearishCompleted), text_color=color.white, bgcolor = bearishBgColor)\n    closedStatsTable.cell(4, 2, str.tostring(bearishCompleted*100/(bearishCompleted+bearishStopped), format.percent), text_color=color.white, bgcolor = bearishBgColor)\n    closedStatsTable.cell(5, 2, str.tostring(riskReward, '#.##'), text_color=color.white, bgcolor = bearishBgColor)\n","updated":"2023-10-02T13:50:36.031986Z","version":"4.0"}