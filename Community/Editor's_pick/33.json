{"created":"2023-10-28T19:13:27.468722Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"3.0","scriptAccess":"open_no_auth","scriptName":"Zig-Zag Volume Profile [Kioseff Trading]","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© KioseffTrading\n\n//@version=5\nindicator(\"Zig-Zag Volume Profile [Kioseff Trading]\", max_lines_count = 500, max_labels_count = 500, overlay= true, max_polylines_count = 100, max_boxes_count = 500)\n\nimport TradingView/ZigZag/6 as ZigZagLib\nimport RicardoSantos/MathOperator/2\n\n\nROWS          = input.int   (defval = 2000, maxval = 9998, minval = 10, step = 10, title = \"Profile Rows\", group = \"Profile Settings\")\nfactor        = input.float (defval = 2.5, minval = 1.1, step = 0.1, title = \"Scaling Factor\", group = \"Profile Settings\")\noffset        = input.int   (defval = 1, title = \"Offset Placement\", minval = 1, group = \"Profile Settings\")\ncurve         = input.bool  (defval = false, title = \"Curved Profiles\", group = \"Profile Settings\")\nsame          = input.string(defval = \"Middle\", title = \"VP Plot Type\", options = [\"Middle\", \"Same Side\", \"Opposing Side\"], group = \"Profile Settings\")\nupCol         = input.color (defval = #14D990, title = \"Bull Color\", group = \"Profile Settings\")\ndnCol         = input.color (defval = #F24968, title = \"Bear Color\", group = \"Profile Settings\")\ntransp        = input.int   (defval = 90, minval = 0, maxval = 100,    group = \"Profile Settings\", title = \"Pofile Fill Transparency\")\ntransp2       = input.int   (defval = 0 , minval = 0, maxval = 100,    group = \"Profile Settings\", title = \"Pofile Line Transparency\")\n\ndelta         = input.bool  (defval = false, title = \"Show Delta\", group = \"Delta Settings\")\ndeltaRows     = input.int   (defval = 20, minval = 5, title = \"Delta Rows\", group = \"Delta Settings\")\ndeltaSz       = input.string(defval = \"Tiny\", title = \"Delta Text Size\", options = [\"Tiny\", \"Small\", \"Normal\", \"Large\", \"Huge\"], group = \"Delta Settings\")\n\npoc           = input.bool  (defval = false, title = \"Show POC\", group = \"POC Settings\")\ndelet         = input.bool  (defval = false, title = \"Delete Violated POCs\",  group = \"POC Settings\")\npoctype       = input.string(defval = \"Bull & Bear POC\", title = \"POC Type\", options = [\"Bull & Bear POC\", \"Regular POC\"], group = \"POC Settings\")\nshow          = input.int   (defval = 20, title = \"Historical POCs To Show\", maxval = 250, minval = 1, group = \"POC Settings\") \nlivepoc       = input.bool  (defval = false, title = \"Live POC Only\", group = \"POC Settings\")\ntransp3       = input.int   (defval = 15, minval = 0, maxval = 100, group = \"POC Settings\", title = \"POC Line Transparency\")\ngeneralPOCcol = input.color (defval = color.yellow, title = \"Regular POC Col\", group = \"POC Settings\")\n\nshowVA        = input.bool  (defval = false, title = \"Show Value Area Lines\", group = \"Value Area Settings\")\nvaCumu        = input.float (defval = 70, title = \"Value Area %\", group = \"Value Area Settings\", minval = 5, maxval = 95) / 100\ntransp4       = input.int   (defval = 66, title = \"VA Lines Transparency\", group = \"Value Area Settings\", minval = 0, maxval = 100)\nvatype        = input.string(defval = \"Bull & Bear VA\", title = \"Value Area Type\", group = \"Value Area Settings\", options = [\"Bull & Bear VA\", \"Regular VA\"])\nshowVAS       = input.int   (defval = 20, title = \"Historical Value Areas To Show\", maxval = 250, minval = 1, group = \"Value Area Settings\") \nliveVAS       = input.bool  (defval = false, title = \"Live Value Areas Only\", group = \"Value Area Settings\")\ndeletv        = input.bool  (defval = false, title = \"Delete Violated VAs\",  group = \"Value Area Settings\")\ngeneralVAcol  = input.color (defval = color.white, title = \"Regular VA Col\", group = \"Value Area Settings\")\n\n\nN             = bar_index\n\nshow := switch poctype \n    \n    \"Regular POC\" => show + 1 \n    =>               show * 2\n\nshowVAS := switch vatype \n    \n    \"Regular VA\"  => showVAS * 2 + 1\n    =>               showVAS * 4 + 1\n\nif curve \n    ROWS := 60 \nif same == \"Middle\" \n    offset := 0\n\n// Create Zig Zag instance from user settings.\nvar zigZag = ZigZagLib.newInstance(\n  ZigZagLib.Settings.new(\n      input.float(0.00001, \"Price deviation for reversals (%)\", 0.00001, 100.0, 0.5, \"0.00001 - 100\", group = \"Zig Zag Settings\"),\n      input.int(100, \"Pivot legs\", 2, group = \"Zig Zag Settings\"),\n      input(color.new(color.white,50), \"Line color\", group = \"Zig Zag Settings\"),\n      false, // input(false, \"Extend to last bar\"),\n      input(false, \"Display reversal price\", group = \"Zig Zag Settings\"),\n      input(false, \"Display cumulative volume\", group = \"Zig Zag Settings\"),\n      input(false, \"Display reversal price change\", inline = \"priceRev\", group = \"Zig Zag Settings\"),\n      input.string(\"Absolute\", \"\", [\"Absolute\", \"Percent\"], inline = \"priceRev\", group = \"Zig Zag Settings\"),\n      true)\n ),   atr = ta.atr(14)\n\n\nzigZag.update()\n\n\ntype dataStore\n\n    matrix <float>        timeVolMat \n    matrix <float>        HLmat\n    array  <int>          retArr \n    array  <box>          pocs \n    matrix <float>        tickLevels\n    array  <label>        deltaLabels\n    map    <float, float> mappedLevel\n    array  <box>          vas\n\nvar data = dataStore.new(matrix.new<float>(2, 0), matrix.new<float>(2, 0), array.new_int(), array.new_box(), vas = array.new_box()),                                                                                                                                                                       //kioseff\ntLevels  = dataStore.new(tickLevels = matrix.new<float>(3, ROWS, 0.0)) \n\ndetermine( a, b, c) => \n\n    result = switch same \n\n        \"Opposing Side\" => a\n        \"Same Side\"     => b\n        \"Middle\"        => c\n\nmethod double_binary_search_leftmost(array <float> id, i) =>\n\n    n  = id .binary_search_leftmost  (data.HLmat.get(0, i))\n    n1 = id .binary_search_leftmost  (data.HLmat.get(1, i))\n\n    [n, n1]\n\nmethod double_binary_search_leftmost_delta(array <float> id, top, btm) =>\n\n    n   = id .binary_search_leftmost  (top)\n    n1  = id .binary_search_leftmost  (btm)\n\n    [n, n1]\n\nmethod effSwitch(matrix<float> id, i, x, div, subtract) =>\n\n    switch data.retArr.get(i)\n\n        1  => id.set(1, x, id.get(1, x) + data.timeVolMat.get(1, i - subtract) / div)\n        -1 => id.set(2, x, id.get(2, x) + data.timeVolMat.get(1, i - subtract) / div)\n\n\nmethod keyLevelsCheck(array<box> id, array<float> timeRow, getx2, usePOC) =>\n\n\n    for i = 0 to timeRow.indexof(getx2) - 1\n\n        if data.HLmat.get(0, i) >= id.last().get_top() and data.HLmat.get(1, i) <= id.last().get_top()\n            id.last().set_right(N - i)\n\n        if usePOC \n            if poctype == \"Bull & Bear POC\"\n            \n                if data.HLmat.get(0, i) >= id.get(id.size() - 2).get_top() and data.HLmat.get(1, i) <= id.get(id.size() - 2).get_top()\n                    id.get(id.size() - 2).set_right(N - i)\n        else \n            if vatype == \"Bull & Bear VA\"\n\n                for x = 2 to 4\n\n                    if data.HLmat.get(0, i) >= id.get(id.size() - x).get_top() and data.HLmat.get(1, i) <= id.get(id.size() - x).get_top()\n                        id.get(id.size() - x).set_right(N - i)\n            else \n            \n                if data.HLmat.get(0, i) >= id.get(id.size() - 2).get_top() and data.HLmat.get(1, i) <= id.get(id.size() - 2).get_top()\n                    id.get(id.size() - 2).set_right(N - i)\n\nmethod drawPOC(array<box> id, difference, idrow, check, newRowUp, newRowDn, remove, array<float> timeRow = na, int getx2 = na, int getx = na, cond1 = false) => \n    \n    if remove \n        if id.size() > 0 \n            for i = 0 to id.size() - 1\n                id.shift().delete()\n\n    if poc \n\n        start = switch\n\n            same == \"Middle\" => cond1 ?  math.round(math.avg(last_bar_index, last_bar_index - timeRow.indexof(line.all.last().get_x2()))) : \n                                         N - math.round(math.avg(timeRow.indexof(getx), timeRow.indexof(getx2))) + 1\n            =>                  difference  + offset - 1\n\n        if poctype == \"Bull & Bear POC\"\n\n            id.push(box.new(start, idrow.get(newRowUp.indexof(newRowUp.max())), N, idrow.get(newRowUp.indexof(newRowUp.max())) ,\n                     bgcolor = #00000000, border_color = color.new(upCol, transp3)))\n\n            id.push(box.new(start, idrow.get(newRowDn.indexof(newRowDn.max())), N, idrow.get(newRowDn.indexof(newRowDn.max())),\n                     bgcolor = #00000000, border_color = color.new(dnCol, transp3)))\n\n        else \n\n            for i = 0 to newRowUp.size() - 1\n                newRowUp.set(i, newRowUp.get(i) + newRowDn.get(i))\n\n            id.push(box.new(start, idrow.get(newRowUp.indexof(newRowUp.max())), N, idrow.get(newRowUp.indexof(newRowUp.max())) ,\n                     bgcolor = #00000000, border_color = color.new(generalPOCcol, transp3)))\n\n        if check\n\n            id.keyLevelsCheck(timeRow, getx2, true)\n\nmethod setLevels(matrix<float> id, float gety, float gety2, cond) =>\n\n    rows = math.abs(gety2 - gety) / (ROWS - 1)\n\n    start = switch cond \n\n        false => math.min(gety, gety2)\n        =>       gety\n\n    for i = 0 to ROWS - 1\n        id.set(0, i, start + rows * i)\n\nmethod createPoly(matrix<chart.point> id, array<float> timeRow, int add, int getx2, int getx, bool cond, int difference, \n                                     array<float> idrow, array<float> lows, array<float> highs) => \n\n    avg = switch cond \n\n        false => math.round(math.avg(timeRow.indexof(getx2), timeRow.indexof(getx)))\n        =>       math.round(math.avg(last_bar_index, last_bar_index - timeRow.indexof(line.all.last().get_x2())))\n\n    add2 = determine(N - timeRow.indexof(getx2), N - avg, add)    \n\n    oper = switch cond\n\n        false => determine(add2 - offset + 1, add  + offset - 1, N - avg + 1)\n        =>       determine(N  - offset + 1, difference + offset - 1, avg)\n\n\n    [finx, finDn, finUp] = if same != \"Middle\"    \n\n        switch cond \n\n            false => [add + offset - 1, idrow.min(), idrow.max()]\n            =>       [difference + offset - 1, lows.min(), highs.max()]\n\n    else \n\n        switch cond \n\n            false => [N - avg + 1, idrow.min(), idrow.max()]\n            =>       [avg, lows.min(), highs.max()]\n\n    id.add_col(0, \n             array.from(chart.point.from_index(finx, finDn) ,chart.point.from_index(oper, finDn)))\n\n    id.add_col(id.columns(), \n             array.from(chart.point.from_index(finx, finUp),chart.point.from_index(oper, finUp))) \n\n    polyline.new(id.row(0), fill_color = color.new(upCol, transp), line_color  = color.new(upCol, transp2), curved = curve)\n    polyline.new(id.row(1), fill_color = color.new(dnCol, transp), line_color  = color.new(dnCol, transp2), curved = curve)\n\n\nnorm(newRowUp, newRowDn, oldMin, oldMax, newRange, i) => \n\n    calcUp = 1 + ((newRowUp.get(i) - oldMin) / (oldMax - oldMin)) * (newRange - 1)\n    calcDn = 1 + ((newRowDn.get(i) - oldMin) / (oldMax - oldMin)) * (newRange - 1)\n\n    [calcUp, calcDn]\n\n\nmethod calcDelta(array<float> id, array<float> newRowUp, array<float> newRowDn, float getY, float getY2, int middle) => \n \n    if delta \n\n        var dsz = switch deltaSz\n\n            \"Tiny\"   => size.tiny \n            \"Small\"  => size.small \n            \"Normal\" => size.normal \n            \"Large\"  => size.large\n            \"Huge\"   => size.huge\n\n        db           = dataStore.new(mappedLevel = map.new<float, float>(), deltaLabels = array.new_label())\n        var lastdb   = dataStore.new(deltaLabels = array.new_label())     \n        var liveBox  = array.new_box()\n\n        if lastdb.deltaLabels.size() > 0 \n            for i = lastdb.deltaLabels.size() - 1 to 0 \n                lastdb.deltaLabels.remove(i).delete()\n\n        if liveBox.size() > 0 \n            liveBox.remove(0).delete() \n\n        newSlice = (math.max(getY, getY2) - math.min(getY, getY2)) / deltaRows\n\n        idx = switch bar_index == last_bar_index\n\n            true => lastdb.deltaLabels\n            =>      db.deltaLabels\n\n        for i = 0 to deltaRows - 1\n                \n            db.mappedLevel.put(i, 0.0)\n\n            btm = math.min(getY, getY2) + (newSlice * i)\n            top = math.min(getY, getY2) + (newSlice * (i + 1))\n\n            idx.push(label.new(chart.point.from_index(middle, math.avg(top, btm)),\n                             textcolor = color.white, style = label.style_none, color = #00000000, size = dsz))\n\n            [topCol, btmCol] = id.double_binary_search_leftmost_delta(top, btm)\n\n            for x = btmCol to topCol\n\n                db.mappedLevel.put(i, db.mappedLevel.get(i) + (newRowUp.get(x) - newRowDn.get(x)))\n\n        valArr = db.mappedLevel.values(), valArr.sort(order.ascending), array <float> pos = na, array <float> neg = na\n\n        if valArr.last ().over (0)\n            pos := valArr.slice(   valArr.binary_search_rightmost(0), valArr.size())\n        if valArr.first().under(0)\n            neg := valArr.slice(0, valArr.binary_search_leftmost (0))\n\n        for i = 0 to deltaRows - 1\n\n            col = switch math.sign(db.mappedLevel.get(i))\n\n                1  => color.from_gradient(db.mappedLevel.get(i), pos.min(), pos.max(), color.new(upCol, 50), color.new(upCol, 10))\n                -1 => color.from_gradient(db.mappedLevel.get(i), neg.max(), neg.min(), color.new(dnCol, 10), color.new(dnCol, 50))\n                =>    color.new(color.white, 75)\n\n            idx.get(i).set_textcolor        (col),\n            idx.get(i).set_text(str.tostring(db.mappedLevel.get(i), format.volume))\n\n        sumCol = switch math.sign(newRowUp.sum() - newRowDn.sum())\n\n            1  => upCol\n            -1 => dnCol \n            =>  color.white\n\n\n        if bar_index < last_bar_index\n\n            box.new(chart.point.from_index(middle - 5, math.max(getY, getY2) + atr * 2), chart.point.from_index(middle + 5, math.max(getY, getY2) + atr), \n                                                  bgcolor      = color.new(sumCol, 80), \n                                                  text_color   = color.white, \n                                                  border_color = sumCol, \n                                                  text         = str.tostring(newRowUp.sum() - newRowDn.sum(), format.volume))\n        if bar_index == last_bar_index \n\n            liveBox.push(box.new(chart.point.from_index(middle - 5, math.max(getY, getY2) + atr * 2), chart.point.from_index(middle + 5, math.max(getY, getY2) + atr), \n                                                  bgcolor      = color.new(sumCol, 80), \n                                                  text_color   = color.white, \n                                                  border_color = sumCol, \n                                                  text         = str.tostring(newRowUp.sum() - newRowDn.sum(), format.volume)))\n\n\n\nmethod calcVA(array<box> id, id2, newRowUp, newRowDn, getx, getx2, timeRow, check, remove, cond = false) => \n\n    if showVA\n\n        if remove \n            if id.size() > 0 \n                for i = 0 to id.size() - 1\n                    id.shift().delete()\n\n        maxU = newRowUp.indexof(newRowUp.max()), bottom  = 0, top  = 0\n        maxD = newRowDn.indexof(newRowDn.max()), bottomD = 0, topD = 0\n\n        if vatype == \"Bull & Bear VA\"\n\n            for i = 0 to newRowUp.size() - 1\n\n                slice = newRowUp.slice(math.max(maxU - i, 0), math.min(maxU + i + 1, newRowUp.size()))\n\n                if slice.sum() / newRowUp.sum() >= vaCumu\n\n                    bottom := math.max(maxU - i, 0)\n                    top    := math.min(maxU + i + 1, newRowUp.size() - 1)\n\n                    break\n\n            for i = 0 to newRowDn.size() - 1\n\n                slice = newRowDn.slice(math.max(maxD - i, 0), math.min(maxD + i + 1, newRowDn.size()))\n\n                if slice.sum() / newRowDn.sum() >= vaCumu\n\n                    bottomD := math.max(maxD - i, 0)\n                    topD    := math.min(maxD + i + 1, newRowDn.size() - 1)\n\n                    break\n\n        if vatype != \"Bull & Bear VA\"\n\n            newValues = array.new_float()\n\n            for i = 0 to newRowUp.size() - 1\n\n                newValues.push(newRowUp.get(i) + newRowDn.get(i))\n\n\n            max = newValues.indexof(newValues.max())\n\n            for i = 0 to newValues.size() - 1\n\n                slice = newValues.slice(math.max(max - i, 0), math.min(max + i + 1, newValues.size()))\n\n                if slice.sum() / newValues.sum() >= vaCumu\n\n                    bottom := math.max(max - i, 0)\n                    top    := math.min(max + i + 1, newValues.size() - 1)\n\n                    break\n            \n\n        left = if not cond \n\n            switch same \n\n                \"Middle\" => math.round(N - math.avg(timeRow.indexof(getx), timeRow.indexof(getx2))) + 1\n                =>          getx\n\n        else \n\n            switch same \n\n                \"Middle\" => math.round(math.avg(N, N - getx2))\n                =>          N - getx2 \n\n\n        if vatype == \"Bull & Bear VA\"\n\n            for i = 0 to 3 \n\n                [yval, colval] = switch  \n\n                    i == 0 => [bottom , upCol]\n                    i == 1 => [top    , upCol] \n                    i == 2 => [bottomD, dnCol]\n                    i == 3 => [topD   , dnCol]\n\n                id.push(box.new(chart.point.from_index(left, id2.get(yval)), chart.point.from_index(N, id2.get(yval)), \n                                  bgcolor = color.new(colval, transp4), border_color = color.new(colval, transp4))),\n\n        if vatype != \"Bull & Bear VA\"\n\n            id.push(box.new(chart.point.from_index(left, id2.get(bottom)), chart.point.from_index(N, id2.get(bottom)), \n                                  bgcolor = color.new(generalVAcol, transp4), border_color = color.new(generalVAcol, transp4))),\n            \n            id.push(box.new(chart.point.from_index(left, id2.get(top)), chart.point.from_index(N, id2.get(top)), \n                                  bgcolor = color.new(generalVAcol, transp4), border_color = color.new(generalVAcol, transp4))),\n                         \n\n        if check\n\n            data.vas.keyLevelsCheck(timeRow, getx2, false)\n\n        id\n\nmethod setCoordsHistory(matrix<chart.point> id, newRowUp, newRowDn, oldMin, oldMax, newRange, timeRow, getx, getx2, idrow) =>\n\n    avg = math.round(math.avg(timeRow.indexof(getx), timeRow.indexof(getx2)))\n\n    for i = 0 to newRowUp.size() - 1\n\n        [calcUp, calcDn] = norm(newRowUp, newRowDn, oldMin, oldMax, newRange, i)\n\n        newSwitchUp = switch same\n\n            \"Middle\" => N - avg + calcUp\n            =>          N - timeRow.indexof(getx) + offset - calcUp\n\n        newXUp = switch same \n            \n            \"Middle\" =>  math.min(newSwitchUp, N - avg)\n            =>           math.max(newSwitchUp, N - timeRow.indexof(getx) + offset)\n\n        newSwitchDn =  determine(N - timeRow.indexof(getx2) - offset + calcDn, \n                                 N - timeRow.indexof(getx ) + offset - calcDn, \n                                 N - avg  - calcDn)\n\n        newXDn      =  determine(math.min(newSwitchDn, N - timeRow.indexof(getx2) - offset),\n                                 math.max(newSwitchDn, N - timeRow.indexof(getx ) + offset),\n                                 math.max(newSwitchDn, N - avg) + 2)\n\n        id.set(0, i, chart.point.from_index(math.round(newXUp), idrow.get(i)))\n        id.set(1, i, chart.point.from_index(math.round(newXDn), idrow.get(i)))\n\n\nmethod setCoordsLive(matrix<chart.point> id, newRowUp, newRowDn, oldMin, oldMax, newRange, difference, newLevelsMat, timeRow) =>\n\n    avg = math.round(math.avg(last_bar_index, last_bar_index - timeRow.indexof(line.all.last().get_x2())))\n\n    for i = 0 to newRowUp.size() - 1\n\n        [calcUp, calcDn] = norm(newRowUp, newRowDn, oldMin, oldMax, newRange, i)\n\n        newSwitchUp      = switch same\n\n            \"Middle\" =>  avg - calcUp\n            =>           difference + offset + calcUp - 1\n\n        newXUp           = switch same \n\n            \"Middle\" => math.min(newSwitchUp, avg - 1)\n            =>          math.max(newSwitchUp, difference + offset)\n\n        newSwitchDn = determine( N - offset - calcDn,\n                                 difference + offset + calcDn - 1, \n                                 avg + calcDn - 1)\n        \n        newXDn      = determine( math.min(newSwitchDn, N - offset - 1),\n                                 math.max(newSwitchDn, difference + 1),\n                                 math.max(newSwitchDn, avg + 1))\n\n        id.add_col(id.columns(), array.from(\n                         chart.point.from_index(math.round(newXUp), newLevelsMat.get(0, i)),\n                         chart.point.from_index(math.round(newXDn), newLevelsMat.get(0, i))))\n    \nmethod update(matrix<float> id) => \n\n    data.timeVolMat.add_col(0, array.from(time, volume))\n    data.HLmat     .add_col(0, array.from(high, low))\n    data.retArr    .unshift(int(math.sign(close - open)))\n\n    change = line.all.size() > line.all.size()[1] and line.all.size() > 2   \n\n    if last_bar_index - N <= 10000\n \n        barCond = barstate.islastconfirmedhistory\n\n        [minus, minus1] = switch barCond\n\n            true => [2, 1]\n            =>      [3, 2]\n\n        if change or barCond\n\n            all = line.all, allSize = all.size()\n\n            getx  = all.get(allSize - minus) .get_x2(), gety  = all.get(allSize - minus) .get_y2()\n            getx2 = all.get(allSize - minus1).get_x2(), gety2 = all.get(allSize - minus1).get_y2()\n \n            id.setLevels(gety, gety2, false)\n\n            timeRow = data.timeVolMat.row(0), idrow = id.row(0)\n\n            for i = timeRow.indexof(getx) to timeRow.indexof(getx2)\n\n                [l1, l2] = idrow.double_binary_search_leftmost(i)\n\n                div = math.abs(l1 - l2) + 1\n\n                for x = l1 to l2 \n\n                    id.effSwitch(i, x, div, 0)\n\n\n            newRange = math.floor((timeRow.indexof(getx2) - timeRow.indexof(getx)) / factor)\n            newRowUp = id.row(1), newRowDn = id.row(2)\n            oldMin   = math.min(newRowUp.min(), newRowDn.min())  \n            oldMax   = math.max(newRowUp.max(), newRowDn.max())\n\n            coordinates = matrix.new<chart.point>(2, newRowUp.size())\n\n            add  = N - timeRow.indexof(getx)\n\n            coordinates.setCoordsHistory(newRowUp, newRowDn, oldMin, oldMax, newRange, timeRow, getx, getx2, idrow)\n            coordinates.createPoly(timeRow, add, getx2, getx, false, na, idrow, na, na)\n            middle = N - math.round(math.avg(timeRow.indexof(getx), timeRow.indexof(getx2))) + 1\n            idrow.calcDelta(newRowUp, newRowDn, gety, gety2, middle)\n\n            if not livepoc\n                data.pocs  .drawPOC(add, idrow, true, newRowUp, newRowDn, false, timeRow, getx2, getx)\n            if not liveVAS\n                data.vas.calcVA(idrow, newRowUp, newRowDn, getx, getx2, timeRow, true, false)\n\nrealtime () => \n\n    if barstate.islast\n\n        var keyLevelsLive    = dataStore.new(pocs = array.new_box(), vas = array.new_box())\n        var coordinates = matrix.new<chart.point>(2, 0)\n        \n        if coordinates.columns() > 0 \n\n            for i = 0 to 1\n                polyline.all.pop().delete()\n\n            for i = 0 to coordinates.columns() - 1\n                coordinates.remove_col()\n\n        timeRow    = data.timeVolMat.row(0)\n        startIndex = timeRow.indexof(line.all.last().get_x2()) \n\n        highs = data.HLmat.row(0).slice(0, startIndex + 1)\n        lows  = data.HLmat.row(1).slice(0, startIndex + 1)\n\n        newLevelsMat = matrix.new<float>(3, ROWS, 0.0)\n        newLevelsMat.setLevels(lows.min(), highs.max(), true)\n\n        levelsArr = newLevelsMat.row(0)\n\n        for i = 0 to startIndex\n            \n            [l1, l2] = levelsArr.double_binary_search_leftmost(i)\n\n            div = math.abs(l1 - l2) + 1\n\n            for x = l1 to l2 \n\n                newLevelsMat.effSwitch(i, x, div, 0)\n\n    \n        difference = N - startIndex\n        newRange   = math.floor((N - difference) / factor)\n        newRowUp   = newLevelsMat.row(1), newRowDn = newLevelsMat.row(2)\n        oldMin     = math.min(newRowUp.min(), newRowDn.min())  \n        oldMax     = math.max(newRowUp.max(), newRowDn.max())\n\n \n        coordinates.setCoordsLive(newRowUp, newRowDn, oldMin, oldMax, newRange, difference, newLevelsMat, timeRow)\n        coordinates.createPoly(timeRow, na, na, na, true, difference, na, lows, highs)\n        keyLevelsLive.pocs.drawPOC(difference, levelsArr, false, newRowUp, newRowDn, true, timeRow = timeRow, cond1 = true)\n        levelsArr.calcDelta(newRowUp, newRowDn, lows.min(), highs.max(), math.round(math.avg(N, N - startIndex)))\n        keyLevelsLive.vas.calcVA(levelsArr, newRowUp, newRowDn, startIndex, startIndex, timeRow, false, true, true)\n\n\nmethod keyLevelsUpdate(array<box> id, int limit, bool deletinput) => \n\n    if id.size() > 0 \n        for i = 0 to id.size() - 1\n\n            if high < id.get(i).get_top() or low > id.get(i).get_top()\n                if id.get(i).get_right() == N - 1 \n                    id.get(i).set_right(N)\n\n            else if deletinput \n                id.get(i).delete()\n            \n            if deletinput\n                if id.get(i).get_right() != N \n                    id.get(i).delete()\n\n    if barstate.islast \n\n        if id.size() > limit     \n            for i = 0 to id.size() - limit \n                id.get(i).delete()  \n\ntLevels.tickLevels.update(), data.pocs.keyLevelsUpdate(show, delet), data.vas.keyLevelsUpdate(showVAS, deletv), realtime()\n\n","updated":"2023-10-28T19:13:27.468722Z","version":"3.0"}