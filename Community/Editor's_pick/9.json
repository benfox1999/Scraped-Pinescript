{"created":"2024-03-30T01:01:38.656008Z","extra":{"kind":"study","sourceInputsCount":1},"lastVersionMaj":"2.0","scriptAccess":"open_no_auth","scriptName":"Higher-timeframe requests","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © PineCoders\n\n//@version=5\nindicator(\"Higher-timeframe requests\", \"\", true)\n\n// Higher-timeframe requests\n// v1, 2024.03.29\n\n// This code was written using the recommendations from the Pine Script™ User Manual's Style Guide:\n//   https://www.tradingview.com/pine-script-docs/en/v5/writing/Style_guide.html\n\n\n\n//#region ———————————————————— Constants and inputs\n\n\n// Constants\ncolor  GRAY    = color.gray\ncolor  WHITE   = color.white\ncolor  ORANGE  = color.orange\ncolor  FUCHSIA = color.fuchsia\ncolor  LIME    = color.lime\nstring TICKER  = syminfo.tickerid\nstring ON      = \"On\"\nstring OFF     = \"Off\"\nstring TF0     = \"Fixed TF\"\nstring TF1     = \"Multiple of chart TF\"\n\n// Tooltips\nstring TT_TFT = \"The higher timeframe selection method. Possible options: '\" + TF0 + \"'' or '\" + TF1 + \"'.\"\nstring TT_FTF = \"A fixed timeframe value. If the 'HTF Selection' value is 'Fixed TF', this input determines the \n     higher timeframe for the data requests.\"\nstring TT_TFM = \"The multiplier applied to the chart's timeframe. For example, the higher timeframe calculated on a \n     15m chart with a multiple of 4 is 60m (1h). This input only affects the output when using 'Multiple of chart TF' \n     as the 'HTF Selection' value.\"\n\n// Inputs\nstring GRP1         = \"Calculations\"\nbool   repaintInput = input.string(OFF,     \"Repainting\",                group = GRP1, options = [ON, OFF]) == ON\nfloat  srcInput     = input.source(close,   \"Source\",                    group = GRP1)\nstring tfTypeInput  = input.string(TF1,     \"HTF Selection\",             group = GRP1, options = [TF0, TF1], tooltip = TT_TFT)\nstring fixedTfInput = input.timeframe(\"1D\", \"  Fixed Higher Timeframe:\", group = GRP1,                       tooltip = TT_FTF)\nint    tfMultInput  = input.int(4,          \"  Timeframe Multiple\",      group = GRP1, minval = 1,           tooltip = TT_TFM)\n\nstring GRP2                 = \"Timeframe Display\"\nbool   showInfoBoxInput     = input.bool(true,       \"Show timeframe\",                group = GRP2)\nstring infoBoxSizeInput     = input.string(\"large\",  \"Size \",          inline = \"21\", group = GRP2, options = [\"tiny\", \"small\", \"normal\", \"large\", \"huge\", \"auto\"])\nstring infoBoxYPosInput     = input.string(\"bottom\", \"↕\",              inline = \"21\", group = GRP2, options = [\"top\", \"middle\", \"bottom\"])\nstring infoBoxXPosInput     = input.string(\"right\",  \"↔\",              inline = \"21\", group = GRP2, options = [\"left\", \"center\", \"right\"])\ncolor  infoBoxColorInput    = input.color(GRAY,      \"\",               inline = \"21\", group = GRP2)\ncolor  infoBoxTxtColorInput = input.color(WHITE,     \"T\",              inline = \"21\", group = GRP2)\n//#endregion\n\n\n\n//#region ———————————————————— Calculations\n\n\n// @variable A multiple of the chart's timeframe or a fixed higher timeframe, depending on the `tfTypeInput` value.\nstring requestedTf = switch tfTypeInput\n    TF0 => fixedTfInput\n    TF1 => timeframe.from_seconds(timeframe.in_seconds() * tfMultInput)\n\n\n// ————— Variant 1. Basic non-repainting HTF `request.security()` call (LIME)\n\n// Here, we demonstrate a non-repainting HTF request in its simplest form. The call uses `barmerge.lookahead_on`,\n// meaning the function looks ahead to the final values of historical bars and references the current value on realtime \n// bars. However, since the `expression` in the call (`srcInput`) is offset by 1 bar, the \"future\" data the function \n// accesses is never from the future. It always represents the value from the last confirmed HTF bar. \n\n\n// @variable The `srcInput` value from the last confirmed bar on the `requestedTf`.\nfloat c0 = request.security(TICKER, requestedTf, srcInput[1], lookahead = barmerge.lookahead_on)\n\n\n// ————— Variant 2. `htfSecurity()` with repainting control (FUCHSIA)\n\n// Here, the `htfSecurity()` function wraps `request.security()` to allow convenient control of repainting behavior. \n// When its `repaint` value is `false`, it offsets the input expression by one bar and uses `barmerge.lookahead_on` \n// as the `lookahead` value in the data request. \n\n// NOTE: This function cannot accept a tuple as its `expression` argument. However, it can accept an object of a \n//       user-defined type (UDT) to achieve a similar result. For a demonstration of a non-repainting tuple request, \n//       see Method 3 below.\n\n\n// @function            A wrapper for `request.security()` with HTF repainting control. \n// @param symbol        (simple string) Symbol to request the data from.\n// @param timeframe     (simple string) Timeframe of the requested data. Must be greater than the chart's timeframe. \n// @param expression    (<any type>) An expression to calculate and return from the requested context.\n// @param repaint       (simple bool) Condition to determine whether the requested `expression` can repaint. \n//                      Optional. Default is false.\n// @returns             (<any type>) The value of the `expression` from the requested `symbol` and `timeframe`.\nhtfSecurity(simple string symbol, simple string timeframe, expression, simple bool repaint = false) => \n    if timeframe.in_seconds(timeframe) <= timeframe.in_seconds() \n        runtime.error(\n             \"The requested timeframe (\" + timeframe + \") is too small. Select a higher timeframe.\" \n         )\n    int offset = repaint ? 0 : 1\n    lookahead  = repaint ? barmerge.lookahead_off : barmerge.lookahead_on\n    result     = request.security(symbol, timeframe, expression[offset], lookahead = lookahead)\n\n// Return `srcInput` from the requested context using `htfSecurity()`, controlling repainting with `repaintInput`. \nfloat c1 = htfSecurity(TICKER, requestedTf, srcInput, repaintInput)\n\n\n// ————— Variant 3. Non-repainting calls returning tuples (WHITE)\n\n// While the `htfSecurity()` function above will allow one to easily request most types of data with repainting \n// control, scripts cannot use tuples as arguments in user-defined functions. If one needs to request a tuple from a \n// higher-timeframe context with repainting control, they can apply the above function's logic in the outer scope. \n\n\n// Set `offset` and `lookahead` variables based on `repaintInput` to control repainting: \n// 0 and `barmerge.lookahead_off` for repainting, 1 and `barmerge.lookahead_on` for non-repainting.\nint offset = repaintInput ? 0 : 1\nlookahead  = repaintInput ? barmerge.lookahead_off : barmerge.lookahead_on\n\n// Request a tuple of the `open` and `srcInput` using `offset` and `lookahead` to manage repainting.\n// Note that each expression in the tuple applies the `offset`.\n[o2, c2] = request.security(TICKER, requestedTf, [open[offset], srcInput[offset]], lookahead = lookahead)\n\n\n// ————— Variant 4, Control. Default `request.security()` call, which is subject to repainting. (ORANGE)\n\n// Here, we included a `request.security()` call with default settings as a reference point. \n// Unlike the variants outlined above, this call behaves differently on historical and realtime bars. \n// When the script restarts its execution pattern, what were once considered realtime bars become historical bars.\n// Consequently, the results across those bars may repaint. \n\n\n// @variable The `srcInput` value from the `TICKER` on the `requestedTf` timeframe. Its result can repaint.\nfloat c3 = request.security(TICKER, requestedTf, srcInput)\n//#endregion\n\n\n\n//#region ———————————————————— Errors and outputs\n\n\n// Raise a runtime error when the user-selected TF isn't higher than the chart TF.\nif timeframe.in_seconds(requestedTf) <= timeframe.in_seconds() \n    runtime.error(\n         \"The requested timeframe (\" + requestedTf + \") is too small. Select a higher timeframe.\"\n     )\n\n// ————— Plot values from `request.security()` examples.\nplot(na, \"══════════ PLOTS\", display = display.data_window)\nplot(c3, \"Method 4: 🔨 Basic repainting call\", color.new(ORANGE, 30), 8)\nplot(c0, \"Method 1: 👍 Non-repaintng call\",    LIME,                  6)\nplot(c1, \"Method 2: 👍 `htfSecurity()`\",       FUCHSIA,               4)\nplot(c2, \"Method 3: 👍 Tuple form\",            WHITE,                 1)\n\n// Plot squares at the chart's bottom, using contrasting colors for historical bars and orange for realtime bars, to \n// visually distinguish bars where data will repaint in variants permitting it.\nplotshape(barstate.ishistory,  \"`barstate.ishistory`\",  shape.square, location.bottom, color.new(chart.fg_color, 70))\nplotshape(barstate.isrealtime, \"`barstate.isrealtime`\", shape.square, location.bottom, color.new(ORANGE,         50))\n\n// Mark timeframe changes by highlighting the background gray.\nbgcolor(timeframe.change(requestedTf) ? color.new(GRAY, 80) : na, title = \"Timeframe change highlight\")\n\n// Display the user-selected TF in a single-cell table.\nif showInfoBoxInput and barstate.islastconfirmedhistory\n    var table tfDisplay = table.new(str.format(\"{0}_{1}\", infoBoxYPosInput, infoBoxXPosInput), 1, 1)\n    table.cell(\n         tfDisplay, 0, 0, requestedTf, bgcolor = infoBoxColorInput, text_color = infoBoxTxtColorInput, \n         text_size = infoBoxSizeInput\n     )\n//#endregion\n","updated":"2024-03-30T01:01:38.656008Z","version":"2.0"}