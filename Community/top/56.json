{"created":"2021-10-04T14:48:07.564625Z","extra":{"kind":"study","sourceInputsCount":1},"lastVersionMaj":"4.0","scriptAccess":"open_no_auth","scriptName":"Linear Regression Channel","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// © LonesomeTheBlue\r\n\r\n//@version=4\r\nstudy(\"Linear Regression Channel\", overlay = true, max_bars_back = 1000, max_lines_count = 300)\r\nsrc = input(defval = close, title = \"Source\")\r\nlen = input(defval = 100, title = \"Length\", minval = 10)\r\ndevlen = input(defval = 2., title = \"Deviation\", minval = 0.1, step = 0.1)\r\nextendit = input(defval = true, title = \"Extend Lines\")\r\nshowfibo = input(defval = false, title = \"Show Fibonacci Levels\")\r\nshowbroken = input(defval = true, title = \"Show Broken Channel\", inline = \"brk\")\r\nbrokencol = input(defval = color.blue, title = \"\", inline = \"brk\")\r\nupcol = input(defval = color.lime, title = \"Up/Down Trend Colors\", inline = \"trcols\")\r\ndncol = input(defval = color.red, title = \"\", inline = \"trcols\")\r\nwidt = input(defval = 2, title = \"Line Width\")\r\n\r\nvar fibo_ratios = array.new_float(0)\r\nvar colors = array.new_color(2)\r\nif barstate.isfirst\r\n    array.unshift(colors, upcol)\r\n    array.unshift(colors, dncol)\r\n    array.push(fibo_ratios, 0.236)\r\n    array.push(fibo_ratios, 0.382)\r\n    array.push(fibo_ratios, 0.618)\r\n    array.push(fibo_ratios, 0.786)\r\n\r\n\r\nget_channel(src, len)=>\r\n    mid = sum(src, len) / len\r\n    slope = linreg(src, len, 0) - linreg(src, len, 1)\r\n    intercept  = mid - slope * floor(len / 2) + ((1 - (len % 2)) / 2) * slope\r\n    endy = intercept  + slope * (len - 1) \r\n    dev = 0.0\r\n    for x = 0 to len - 1\r\n        dev := dev + pow(src[x] - (slope * (len - x) + intercept), 2)\r\n    dev := sqrt(dev/len)\r\n    [intercept, endy, dev, slope]\r\n\r\n[y1_, y2_, dev, slope] = get_channel(src, len)\r\n\r\noutofchannel = (slope > 0 and close < y2_ - dev * devlen) ? 0 : (slope < 0 and close > y2_ + dev * devlen) ? 2 : -1\r\n\r\nvar reglines = array.new_line(3)\r\nvar fibolines = array.new_line(4)\r\nfor x = 0 to 2\r\n    if not showbroken or outofchannel != x or nz(outofchannel[1], -1) != -1\r\n        line.delete(array.get(reglines, x))\r\n    else\r\n        line.set_color(array.get(reglines, x), color = brokencol)\r\n        line.set_width(array.get(reglines, x), width = 2)\r\n        line.set_style(array.get(reglines, x), style = line.style_dotted)\r\n        line.set_extend(array.get(reglines, x), extend = extend.none)\r\n    \r\n    array.set(reglines, x, \r\n              line.new(x1 = bar_index - (len - 1), \r\n                       y1 = y1_ + dev * devlen * (x - 1), \r\n                       x2 = bar_index, \r\n                       y2 = y2_ + dev * devlen * (x - 1),\r\n                       color = array.get(colors, round(max(sign(slope), 0))),\r\n                       style =  x % 2 == 1 ? line.style_solid : line.style_dashed,\r\n                       width = widt,\r\n                       extend = extendit ? extend.right : extend.none))\r\nif showfibo\r\n    for x = 0 to 3\r\n        line.delete(array.get(fibolines, x))\r\n        array.set(fibolines, x, \r\n                  line.new(x1 = bar_index - (len - 1), \r\n                           y1 = y1_ - dev * devlen + dev * devlen * 2 * array.get(fibo_ratios, x), \r\n                           x2 = bar_index, \r\n                           y2 = y2_ - dev * devlen + dev * devlen * 2 * array.get(fibo_ratios, x),\r\n                           color = array.get(colors, round(max(sign(slope), 0))),\r\n                           style =  line.style_dotted,\r\n                           width = widt,\r\n                           extend = extendit ? extend.right : extend.none))\r\n    \r\nvar label sidelab = label.new(x = bar_index - (len - 1), y = y1_, text = \"S\",  size = size.large)\r\ntxt = slope > 0 ? slope > slope[1] ? \"⇑\" : \"⇗\" : slope < 0 ? slope < slope[1] ? \"⇓\" : \"⇘\" : \"⇒\"\r\nstl = slope > 0 ? slope > slope[1] ? label.style_label_up : label.style_label_upper_right : slope < 0 ? slope < slope[1] ? label.style_label_down :  label.style_label_lower_right : label.style_label_right\r\nlabel.set_style(sidelab, stl)\r\nlabel.set_text(sidelab, txt)\r\nlabel.set_x(sidelab, bar_index - (len - 1))\r\nlabel.set_y(sidelab, slope > 0 ? y1_ - dev * devlen : slope < 0 ? y1_ + dev * devlen : y1_)\r\nlabel.set_color(sidelab, slope > 0 ? upcol : slope < 0 ? dncol : color.blue)\r\n\r\nalertcondition(outofchannel, title='Channel Broken', message='Channel Broken')\r\n\r\n// direction\r\ntrendisup = sign(slope) != sign(slope[1]) and slope > 0\r\ntrendisdown = sign(slope) != sign(slope[1]) and slope < 0\r\nalertcondition(trendisup, title='Up trend', message='Up trend')\r\nalertcondition(trendisdown, title='Down trend', message='Down trend')\r\n","updated":"2021-10-04T14:48:07.564625Z","version":"4.0"}