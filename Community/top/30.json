{"created":"2023-02-09T05:01:32.419489Z","extra":{"kind":"study","sourceInputsCount":1},"scriptAccess":"open_no_auth","scriptName":"Machine Learning: Lorentzian Classification","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// ©jdehorty\n\n// @version=5\nindicator('Machine Learning: Lorentzian Classification', 'Lorentzian Classification', true, precision=4, max_labels_count=500) \n\nimport jdehorty/MLExtensions/2 as ml\nimport jdehorty/KernelFunctions/2 as kernels\n\n// ====================\n// ==== Background ====\n// ====================\n\n// When using Machine Learning algorithms like K-Nearest Neighbors, choosing an\n// appropriate distance metric is essential. Euclidean Distance is often used as\n// the default distance metric, but it may not always be the best choice. This is\n// because market data is often significantly impacted by proximity to significant\n// world events such as FOMC Meetings and Black Swan events. These major economic\n// events can contribute to a warping effect analogous a massive object's \n// gravitational warping of Space-Time. In financial markets, this warping effect \n// operates on a continuum, which can analogously be referred to as \"Price-Time\".\n\n// To help to better account for this warping effect, Lorentzian Distance can be\n// used as an alternative distance metric to Euclidean Distance. The geometry of\n// Lorentzian Space can be difficult to visualize at first, and one of the best\n// ways to intuitively understand it is through an example involving 2 feature\n// dimensions (z=2). For purposes of this example, let's assume these two features\n// are Relative Strength Index (RSI) and the Average Directional Index (ADX). In\n// reality, the optimal number of features is in the range of 3-8, but for the sake\n// of simplicity, we will use only 2 features in this example.\n\n// Fundamental Assumptions:\n// (1) We can calculate RSI and ADX for a given chart.\n// (2) For simplicity, values for RSI and ADX are assumed to adhere to a Gaussian \n//     distribution in the range of 0 to 100.\n// (3) The most recent RSI and ADX value can be considered the origin of a coordinate \n//     system with ADX on the x-axis and RSI on the y-axis.\n\n// Distances in Euclidean Space:\n// Measuring the Euclidean Distances of historical values with the most recent point\n// at the origin will yield a distribution that resembles Figure 1 (below).\n\n//                        [RSI]\n//                          |                      \n//                          |                   \n//                          |                 \n//                      ...:::....              \n//                .:.:::••••••:::•::..             \n//              .:•:.:•••::::••::••....::.            \n//             ....:••••:••••••••::••:...:•.          \n//            ...:.::::::•••:::•••:•••::.:•..          \n//            ::•:.:•:•••••••:.:•::::::...:..         \n//  |--------.:•••..•••••••:••:...:::•:•:..:..----------[ADX]    \n//  0        :•:....:•••••::.:::•••::••:.....            \n//           ::....:.:••••••••:•••::••::..:.          \n//            .:...:••:::••••••••::•••....:          \n//              ::....:.....:•::•••:::::..             \n//                ..:..::••..::::..:•:..              \n//                    .::..:::.....:                \n//                          |            \n//                          |                   \n//                          |\n//                          |\n//                         _|_ 0        \n//                          \n//        Figure 1: Neighborhood in Euclidean Space\n\n// Distances in Lorentzian Space:\n// However, the same set of historical values measured using Lorentzian Distance will \n// yield a different distribution that resembles Figure 2 (below).\n\n//                         \n//                         [RSI] \n//  ::..                     |                    ..:::  \n//   .....                   |                  ......\n//    .••••::.               |               :••••••. \n//     .:•••••:.             |            :::••••••.  \n//       .•••••:...          |         .::.••••••.    \n//         .::•••••::..      |       :..••••••..      \n//            .:•••••••::.........::••••••:..         \n//              ..::::••••.•••••••.•••••••:.            \n//                ...:•••••••.•••••••••::.              \n//                  .:..••.••••••.••••..                \n//  |---------------.:•••••••••••••••••.---------------[ADX]          \n//  0             .:•:•••.••••••.•••••••.                \n//              .••••••••••••••••••••••••:.            \n//            .:••••••••••::..::.::••••••••:.          \n//          .::••••••::.     |       .::•••:::.       \n//         .:••••••..        |          :••••••••.     \n//       .:••••:...          |           ..•••••••:.   \n//     ..:••::..             |              :.•••••••.   \n//    .:•....                |               ...::.:••.  \n//   ...:..                  |                   :...:••.     \n//  :::.                     |                       ..::  \n//                          _|_ 0\n//\n//       Figure 2: Neighborhood in Lorentzian Space \n\n\n// Observations:\n// (1) In Lorentzian Space, the shortest distance between two points is not \n//     necessarily a straight line, but rather, a geodesic curve.\n// (2) The warping effect of Lorentzian distance reduces the overall influence  \n//     of outliers and noise.\n// (3) Lorentzian Distance becomes increasingly different from Euclidean Distance \n//     as the number of nearest neighbors used for comparison increases.\n\n// ======================\n// ==== Custom Types ====\n// ======================\n\n// This section uses PineScript's new Type syntax to define important data structures\n// used throughout the script.\n\ntype Settings\n    float source\n    int neighborsCount\n    int maxBarsBack\n    int featureCount\n    int colorCompression\n    bool showExits\n    bool useDynamicExits\n\ntype Label\n    int long\n    int short\n    int neutral\n\ntype FeatureArrays\n    array<float> f1\n    array<float> f2\n    array<float> f3\n    array<float> f4\n    array<float> f5\n\ntype FeatureSeries\n    float f1\n    float f2\n    float f3\n    float f4\n    float f5\n\ntype MLModel\n    int firstBarIndex\n    array<int> trainingLabels\n    int loopSize\n    float lastDistance\n    array<float> distancesArray\n    array<int> predictionsArray\n    int prediction\n\ntype FilterSettings \n    bool useVolatilityFilter\n    bool useRegimeFilter\n    bool useAdxFilter\n    float regimeThreshold\n    int adxThreshold\n\ntype Filter\n    bool volatility\n    bool regime\n    bool adx \n\n// ==========================\n// ==== Helper Functions ====\n// ==========================\n\nseries_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>\n    switch feature_string\n        \"RSI\" => ml.n_rsi(_close, f_paramA, f_paramB)\n        \"WT\" => ml.n_wt(_hlc3, f_paramA, f_paramB)\n        \"CCI\" => ml.n_cci(_close, f_paramA, f_paramB)\n        \"ADX\" => ml.n_adx(_high, _low, _close, f_paramA)\n\nget_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>\n    switch featureCount\n        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + \n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + \n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + \n             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + \n             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))\n        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +\n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +\n             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))\n        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +\n             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))\n        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +\n             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))\n\n// ================  \n// ==== Inputs ==== \n// ================ \n\n// Settings Object: General User-Defined Inputs\nSettings settings = \n Settings.new(\n   input.source(title='Source', defval=close, group=\"General Settings\", tooltip=\"Source of the input data\"),\n   input.int(title='Neighbors Count', defval=8, group=\"General Settings\", minval=1, maxval=100, step=1, tooltip=\"Number of neighbors to consider\"),\n   input.int(title=\"Max Bars Back\", defval=2000, group=\"General Settings\"),\n   input.int(title=\"Feature Count\", defval=5, group=\"Feature Engineering\", minval=2, maxval=5, tooltip=\"Number of features to use for ML predictions.\"),\n   input.int(title=\"Color Compression\", defval=1, group=\"General Settings\", minval=1, maxval=10, tooltip=\"Compression factor for adjusting the intensity of the color scale.\"),\n   input.bool(title=\"Show Default Exits\", defval=false, group=\"General Settings\", tooltip=\"Default exits occur exactly 4 bars after an entry signal. This corresponds to the predefined length of a trade during the model's training process.\", inline=\"exits\"),\n   input.bool(title=\"Use Dynamic Exits\", defval=false, group=\"General Settings\", tooltip=\"Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold based on kernel regression logic.\", inline=\"exits\")\n )\n   \n// Trade Stats Settings\n// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting. It is intended to be used for calibration purposes only.\nshowTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group=\"General Settings\")\nuseWorstCase = input.bool(false, \"Use Worst Case Estimates\", tooltip=\"Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.\", group=\"General Settings\")\n\n// Settings object for user-defined settings\nFilterSettings filterSettings =\n FilterSettings.new(\n   input.bool(title=\"Use Volatility Filter\", defval=true, tooltip=\"Whether to use the volatility filter.\", group=\"Filters\"),\n   input.bool(title=\"Use Regime Filter\", defval=true, group=\"Filters\", inline=\"regime\"),\n   input.bool(title=\"Use ADX Filter\", defval=false, group=\"Filters\", inline=\"adx\"),\n   input.float(title=\"Threshold\", defval=-0.1, minval=-10, maxval=10, step=0.1, tooltip=\"Whether to use the trend detection filter. Threshold for detecting Trending/Ranging markets.\", group=\"Filters\", inline=\"regime\"),\n   input.int(title=\"Threshold\", defval=20, minval=0, maxval=100, step=1, tooltip=\"Whether to use the ADX filter. Threshold for detecting Trending/Ranging markets.\", group=\"Filters\", inline=\"adx\")\n )\n\n// Filter object for filtering the ML predictions\nFilter filter =\n Filter.new(\n   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), \n   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),\n   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)\n  )\n\n// Feature Variables: User-Defined Inputs for calculating Feature Series. \nf1_string = input.string(title=\"Feature 1\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval=\"RSI\", inline = \"01\", tooltip=\"The first feature to use for ML predictions.\", group=\"Feature Engineering\")\nf1_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 1.\", defval=14, inline = \"02\", group=\"Feature Engineering\")\nf1_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 2 (if applicable).\", defval=1, inline = \"02\", group=\"Feature Engineering\")\nf2_string = input.string(title=\"Feature 2\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval=\"WT\", inline = \"03\", tooltip=\"The second feature to use for ML predictions.\", group=\"Feature Engineering\")\nf2_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 2.\", defval=10, inline = \"04\", group=\"Feature Engineering\")\nf2_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 2 (if applicable).\", defval=11, inline = \"04\", group=\"Feature Engineering\")\nf3_string = input.string(title=\"Feature 3\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval=\"CCI\", inline = \"05\", tooltip=\"The third feature to use for ML predictions.\", group=\"Feature Engineering\")\nf3_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 3.\", defval=20, inline = \"06\", group=\"Feature Engineering\")\nf3_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 3 (if applicable).\", defval=1, inline = \"06\", group=\"Feature Engineering\")\nf4_string = input.string(title=\"Feature 4\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval=\"ADX\", inline = \"07\", tooltip=\"The fourth feature to use for ML predictions.\", group=\"Feature Engineering\")\nf4_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 4.\", defval=20, inline = \"08\", group=\"Feature Engineering\")\nf4_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 4 (if applicable).\", defval=2, inline = \"08\", group=\"Feature Engineering\")\nf5_string = input.string(title=\"Feature 5\", options=[\"RSI\", \"WT\", \"CCI\", \"ADX\"], defval=\"RSI\", inline = \"09\", tooltip=\"The fifth feature to use for ML predictions.\", group=\"Feature Engineering\")\nf5_paramA = input.int(title=\"Parameter A\", tooltip=\"The primary parameter of feature 5.\", defval=9, inline = \"10\", group=\"Feature Engineering\")\nf5_paramB = input.int(title=\"Parameter B\", tooltip=\"The secondary parameter of feature 5 (if applicable).\", defval=1, inline = \"10\", group=\"Feature Engineering\")\n\n// FeatureSeries Object: Calculated Feature Series based on Feature Variables\nfeatureSeries = \n FeatureSeries.new(\n   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1\n   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 \n   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3\n   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4\n   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5\n )\n\n// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML\n// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.\nvar f1Array = array.new_float()\nvar f2Array = array.new_float()\nvar f3Array = array.new_float()\nvar f4Array = array.new_float()\nvar f5Array = array.new_float()\narray.push(f1Array, featureSeries.f1)\narray.push(f2Array, featureSeries.f2)\narray.push(f3Array, featureSeries.f3)\narray.push(f4Array, featureSeries.f4)\narray.push(f5Array, featureSeries.f5)\n\n// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object\nfeatureArrays = \n FeatureArrays.new(\n  f1Array, // f1\n  f2Array, // f2\n  f3Array, // f3\n  f4Array, // f4\n  f5Array  // f5\n )\n\n// Label Object: Used for classifying historical data as training data for the ML Model\nLabel direction = \n Label.new(\n   long=1, \n   short=-1, \n   neutral=0\n  )\n\n// Derived from General Settings\nmaxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0\n\n// EMA Settings \nuseEmaFilter = input.bool(title=\"Use EMA Filter\", defval=false, group=\"Filters\", inline=\"ema\")\nemaPeriod = input.int(title=\"Period\", defval=200, minval=1, step=1, group=\"Filters\", inline=\"ema\", tooltip=\"The period of the EMA used for the EMA Filter.\")\nisEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true\nisEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true\nuseSmaFilter = input.bool(title=\"Use SMA Filter\", defval=false, group=\"Filters\", inline=\"sma\")\nsmaPeriod = input.int(title=\"Period\", defval=200, minval=1, step=1, group=\"Filters\", inline=\"sma\", tooltip=\"The period of the SMA used for the SMA Filter.\")\nisSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true\nisSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true\n\n// Nadaraya-Watson Kernel Regression Settings\nuseKernelFilter = input.bool(true, \"Trade with Kernel\", group=\"Kernel Settings\", inline=\"kernel\")\nshowKernelEstimate = input.bool(true, \"Show Kernel Estimate\", group=\"Kernel Settings\", inline=\"kernel\")\nuseKernelSmoothing = input.bool(false, \"Enhance Kernel Smoothing\", tooltip=\"Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.\", inline='1', group='Kernel Settings')\nh = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group=\"Kernel Settings\", inline=\"kernel\")\nr = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group=\"Kernel Settings\", inline=\"kernel\")\nx = input.int(25, \"Regression Level\", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group=\"Kernel Settings\", inline=\"kernel\")\nlag = input.int(2, \"Lag\", tooltip=\"Lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2\", inline='1', group='Kernel Settings')\n\n// Display Settings\nshowBarColors = input.bool(true, \"Show Bar Colors\", tooltip=\"Whether to show the bar colors.\", group=\"Display Settings\")\nshowBarPredictions = input.bool(defval = true, title = \"Show Bar Prediction Values\", tooltip = \"Will show the ML model's evaluation of each bar as an integer.\", group=\"Display Settings\")\nuseAtrOffset = input.bool(defval = false, title = \"Use ATR Offset\", tooltip = \"Will use the ATR offset instead of the bar prediction offset.\", group=\"Display Settings\")\nbarPredictionsOffset = input.float(0, \"Bar Prediction Offset\", minval=0, tooltip=\"The offset of the bar predictions as a percentage from the bar high or close.\", group=\"Display Settings\")\n\n// =================================\n// ==== Next Bar Classification ====\n// =================================\n\n// This model specializes specifically in predicting the direction of price action over the course of the next 4 bars. \n// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other training lengths may be added in the future.\nsrc = settings.source\ny_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral\nvar y_train_array = array.new_int(0)\n\n// Variables used for ML Logic\nvar predictions = array.new_float(0)\nvar prediction = 0.\nvar signal = direction.neutral\nvar distances = array.new_float(0)\n\narray.push(y_train_array, y_train_series)\n\n// =========================\n// ====  Core ML Logic  ====\n// =========================\n\n// Approximate Nearest Neighbors Search with Lorentzian Distance:\n// A novel variation of the Nearest Neighbors (NN) search algorithm that ensures a chronologically uniform distribution of neighbors.\n\n// In a traditional KNN-based approach, we would iterate through the entire dataset and calculate the distance between the current bar \n// and every other bar in the dataset and then sort the distances in ascending order. We would then take the first k bars and use their \n// labels to determine the label of the current bar. \n\n// There are several problems with this traditional KNN approach in the context of real-time calculations involving time series data:\n// - It is computationally expensive to iterate through the entire dataset and calculate the distance between every historical bar and\n//   the current bar.\n// - Market time series data is often non-stationary, meaning that the statistical properties of the data change slightly over time.\n// - It is possible that the nearest neighbors are not the most informative ones, and the KNN algorithm may return poor results if the\n//   nearest neighbors are not representative of the majority of the data.\n\n// Previously, the user @capissimo attempted to address some of these issues in several of his PineScript-based KNN implementations by:\n// - Using a modified KNN algorithm based on consecutive furthest neighbors to find a set of approximate \"nearest\" neighbors.\n// - Using a sliding window approach to only calculate the distance between the current bar and the most recent n bars in the dataset.\n\n// Of these two approaches, the latter is inherently limited by the fact that it only considers the most recent bars in the overall dataset. \n\n// The former approach has more potential to leverage historical price action, but is limited by:\n// - The possibility of a sudden \"max\" value throwing off the estimation\n// - The possibility of selecting a set of approximate neighbors that are not representative of the majority of the data by oversampling \n//   values that are not chronologically distinct enough from one another\n// - The possibility of selecting too many \"far\" neighbors, which may result in a poor estimation of price action\n\n// To address these issues, a novel Approximate Nearest Neighbors (ANN) algorithm is used in this indicator.\n\n// In the below ANN algorithm:\n// 1. The algorithm iterates through the dataset in chronological order, using the modulo operator to only perform calculations every 4 bars.\n//    This serves the dual purpose of reducing the computational overhead of the algorithm and ensuring a minimum chronological spacing \n//    between the neighbors of at least 4 bars.\n// 2. A list of the k-similar neighbors is simultaneously maintained in both a predictions array and corresponding distances array.\n// 3. When the size of the predictions array exceeds the desired number of nearest neighbors specified in settings.neighborsCount, \n//    the algorithm removes the first neighbor from the predictions array and the corresponding distance array.\n// 4. The lastDistance variable is overriden to be a distance in the lower 25% of the array. This step helps to boost overall accuracy \n//    by ensuring subsequent newly added distance values increase at a slower rate.\n// 5. Lorentzian distance is used as a distance metric in order to minimize the effect of outliers and take into account the warping of \n//    \"price-time\" due to proximity to significant economic events.\n\nlastDistance = -1.0\nsize = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)\nsizeLoop = math.min(settings.maxBarsBack-1, size)\n\nif bar_index >= maxBarsBackIndex //{\n    for i = 0 to sizeLoop //{\n        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) \n        if d >= lastDistance and i%4 //{\n            lastDistance := d            \n            array.push(distances, d)\n            array.push(predictions, math.round(array.get(y_train_array, i)))\n            if array.size(predictions) > settings.neighborsCount //{\n                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))\n                array.shift(distances)\n                array.shift(predictions)\n            //}\n        //}\n    //}\n    prediction := array.sum(predictions)\n//}\n\n// ============================\n// ==== Prediction Filters ====\n// ============================\n\n// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions\nfilter_all = filter.volatility and filter.regime and filter.adx\n\n// Filtered Signal: The model's prediction of future price movement direction with user-defined filters applied\nsignal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(signal[1])\n\n// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars\nvar int barsHeld = 0\nbarsHeld := ta.change(signal) ? 0 : barsHeld + 1\nisHeldFourBars = barsHeld == 4\nisHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4\n\n// Fractal Filters: Derived from relative appearances of signals in a given time series fractal/segment with a default length of 4 bars\nisDifferentSignalType = ta.change(signal)\nisEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))\nisBuySignal = signal == direction.long and isEmaUptrend and isSmaUptrend\nisSellSignal = signal == direction.short and isEmaDowntrend and isSmaDowntrend\nisLastSignalBuy = signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]\nisLastSignalSell = signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]\nisNewBuySignal = isBuySignal and isDifferentSignalType\nisNewSellSignal = isSellSignal and isDifferentSignalType\n\n// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational Quadratic Kernel\n// For more information on this technique refer to my other open source indicator located here: \n// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/\nc_green = color.new(#009988, 20)\nc_red = color.new(#CC3311, 20)\ntransparent = color.new(#000000, 100)\nyhat1 = kernels.rationalQuadratic(settings.source, h, r, x)\nyhat2 = kernels.gaussian(settings.source, h-lag, x)\nkernelEstimate = yhat1\n// Kernel Rates of Change\nbool wasBearishRate = yhat1[2] > yhat1[1]\nbool wasBullishRate = yhat1[2] < yhat1[1]\nbool isBearishRate = yhat1[1] > yhat1\nbool isBullishRate = yhat1[1] < yhat1\nisBearishChange = isBearishRate and wasBullishRate\nisBullishChange = isBullishRate and wasBearishRate\n// Kernel Crossovers\nbool isBullishCrossAlert = ta.crossover(yhat2, yhat1)\nbool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) \nbool isBullishSmooth = yhat2 >= yhat1\nbool isBearishSmooth = yhat2 <= yhat1\n// Kernel Colors\ncolor colorByCross = isBullishSmooth ? c_green : c_red\ncolor colorByRate = isBullishRate ? c_green : c_red\ncolor plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent\nplot(kernelEstimate, color=plotColor, linewidth=2, title=\"Kernel Regression Estimate\")\n// Alert Variables\nbool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange\nbool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange\n// Bullish and Bearish Filters based on Kernel\nisBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true\nisBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true\n\n// ===========================\n// ==== Entries and Exits ====\n// ===========================\n\n// Entry Conditions: Booleans for ML Model Position Entries\nstartLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend\nstartShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend\n\n// Dynamic Exit Conditions: Booleans for ML Model Position Exits based on Fractal Filters and Kernel Regression Filters\nlastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)\nlastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)\nbarsSinceRedEntry = ta.barssince(startShortTrade)\nbarsSinceRedExit = ta.barssince(alertBullish)\nbarsSinceGreenEntry = ta.barssince(startLongTrade)\nbarsSinceGreenExit = ta.barssince(alertBearish)\nisValidShortExit = barsSinceRedExit > barsSinceRedEntry\nisValidLongExit = barsSinceGreenExit > barsSinceGreenEntry\nendLongTradeDynamic = (isBearishChange and isValidLongExit[1])\nendShortTradeDynamic = (isBullishChange and isValidShortExit[1])\n\n// Fixed Exit Conditions: Booleans for ML Model Position Exits based on a Bar-Count Filters\nendLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]\nendShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]\nisDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing\nendLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict \nendShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict\n\n// =========================\n// ==== Plotting Labels ====\n// =========================\n\n// Note: These will not repaint once the most recent bar has fully closed. By default, signals appear over the last closed bar; to override this behavior set offset=0.\nplotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)\nplotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)\nplotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)\nplotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)\n\n// ================\n// ==== Alerts ====\n// ================ \n\n// Separate Alerts for Entries and Exits\nalertcondition(startLongTrade, title='Open Long ▲', message='LDC Open Long ▲ | {{ticker}}@{{close}} | ({{interval}})')\nalertcondition(endLongTrade, title='Close Long ▲', message='LDC Close Long ▲ | {{ticker}}@{{close}} | ({{interval}})')\nalertcondition(startShortTrade, title='Open Short ▼', message='LDC Open Short  | {{ticker}}@{{close}} | ({{interval}})')\nalertcondition(endShortTrade, title='Close Short ▼', message='LDC Close Short ▼ | {{ticker}}@{{close}} | ({{interval}})')\n\n// Combined Alerts for Entries and Exits\nalertcondition(startShortTrade or startLongTrade, title='Open Position ▲▼', message='LDC Open Position ▲▼ | {{ticker}}@{{close}} | ({{interval}})')\nalertcondition(endShortTrade or endLongTrade, title='Close Position ▲▼', message='LDC Close Position  ▲▼ | {{ticker}}@[{{close}}] | ({{interval}})')\n\n// Kernel Estimate Alerts\nalertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')\nalertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')\n\n// =========================\n// ==== Display Signals ==== \n// =========================\n\natrSpaced = useAtrOffset ? ta.atr(1) : na\ncompressionFactor = settings.neighborsCount / settings.colorCompression\nc_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na\nc_label = showBarPredictions ? c_pred : na\nc_bars = showBarColors ? color.new(c_pred, 50) : na\nx_val = bar_index\ny_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30\nlabel.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)\nbarcolor(showBarColors ? color.new(c_pred, 50) : na)\n\n// ===================== \n// ==== Backtesting ====\n// =====================\n\n// The following can be used to stream signals to a backtest adapter\nbackTestStream = switch \n    startLongTrade => 1\n    endLongTrade => 2\n    startShortTrade => -1\n    endShortTrade => -2\nplot(backTestStream, \"Backtest Stream\", display=display.none)\n\n// The following can be used to display real-time trade stats. This can be a useful mechanism for obtaining real-time feedback during Feature Engineering. This does NOT replace the need to properly backtest.\n// Note: In this context, a \"Stop-Loss\" is defined instances where the ML Signal prematurely flips directions before an exit signal can be generated.\n[totalWins, totalLosses, totalEarlySignalFlips, totalTrades, tradeStatsHeader, winLossRatio, winRate] = ml.backtest(high, low, open, startLongTrade, endLongTrade, startShortTrade, endShortTrade, isEarlySignalFlip, maxBarsBackIndex, bar_index, settings.source, useWorstCase)\n\ninit_table() =>\n    c_transparent = color.new(color.black, 100)\n    table.new(position.top_right, columns=2, rows=7, frame_color=color.new(color.black, 100), frame_width=1, border_width=1, border_color=c_transparent)\n\nupdate_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, stopLosses) => \n    c_transparent = color.new(color.black, 100)\n    table.cell(tbl, 0, 0, tradeStatsHeader, text_halign=text.align_center, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 0, 1, 'Winrate', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 1, 1, str.tostring(totalWins / totalTrades, '#.#%'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 0, 2, 'Trades', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 1, 2, str.tostring(totalTrades, '#') + ' (' + str.tostring(totalWins, '#') + '|' + str.tostring(totalLosses, '#') + ')', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 0, 5, 'WL Ratio', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 1, 5, str.tostring(totalWins / totalLosses, '0.00'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 0, 6, 'Early Signal Flips', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n    table.cell(tbl, 1, 6, str.tostring(totalEarlySignalFlips, '#'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)\n\nif showTradeStats\n    var tbl = ml.init_table()\n    if barstate.islast\n        update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, totalEarlySignalFlips)","updated":"2023-02-09T05:01:32.419489Z","version":"5.0"}