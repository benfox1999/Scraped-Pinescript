{"created":"2022-02-26T21:26:28.334715Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"12.0","scriptAccess":"open_no_auth","scriptName":"Bjorgum Key Levels","source":"\r\n// █▀▀▄ ──▀ █▀▀█ █▀▀█ █▀▀▀ █──█ █▀▄▀█ \r\n// █▀▀▄ ──█ █──█ █▄▄▀ █─▀█ █──█ █─▀─█ \r\n// ▀▀▀─ █▄█ ▀▀▀▀ ▀─▀▀ ▀▀▀▀ ─▀▀▀ ▀───▀\r\n\r\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// © Bjorgum\r\n\r\n//@version=5\r\nindicator           ('Bjorgum Key Levels', 'Bj Key Levels', overlay= true, max_boxes_count= 500, max_labels_count= 500, max_lines_count=500)\r\n\r\nimport              Bjorgum/BjCandlePatterns/2 as bj\r\n\r\n// ================================== //\r\n// ------------> Tips <-------------- //\r\n// ================================== //\r\n\r\nleftTip         =   \"Look left for swing high/low in x number of bars to form pivot. The higher the number, the higher the script looks to the left for the highest/lowest point before drawing pivot\"        \r\nrightTip        =   \"Look right for swing high/low in x number of bars to form pivot. The higher the number, the higher the script looks to the right for the highest/lowest point before drawing pivot\"       \r\nnPivTip         =   \"This sets the array size, or the number of pivots to track at a time (x highs, and x number of lows)\" \r\natrLenTip       =   \"Number of bars to average. ATR is used to standardize zone width between assets and timeframes\"     \r\nmultTip         =   \"ATR multiplier to set zone width. Default is half of one ATR from box bottom to box top\"     \r\nperTip          =   \"Max zone size as a percent of price. Some assets can be too volatile at low prices creating an unreasonably sized zone\"\r\nmaxTip          =   \"Number of boxes for candlestick patterns to track historically. Note: the higher the number the less pivot zones will be tracked when looking back in time due to the limitation on the number of box elements allowed at once\"\r\nfutTip          =   \"Number of bars to offset labels for price levels\"\r\nsrcTip          =   \"Source input for pivots. Default tracks the highest and lowest bodies of HA candles to average price action, which can result in a level that sits in the overlap of support and resistance\"     \r\nalignZonesTip   =   \"Aligns recurring zones who's edges overlap an existing zone creating a zone that ages in time and intensifies visually\"     \r\nextendTip       =   \"Extends current zones right\"\r\nlLabTip         =   \"Show labels for price levels extended off Key Levels\"\r\n\r\ndhighsTip       =   \"Disabling will prevent highs from being tracked\"          \r\ndlowsTip        =   \"Disabling will prevent lows from being tracked\"         \r\ndetectBOTip     =   \"Show points that price action breaks above all pivots. An arrow from below is displayed\"        \r\ndetectBDTip     =   \"Show points that price action breaks below all pivots. An arrow from above is displayed\"         \r\nbreakUpTip      =   \"Show points that price action breaks above resistance. An arrow from below is displayed\"         \r\nbreakDnTip      =   \"Show points that price action breaks below support. An arrow from above is displayed\"          \r\nfalseBullTip    =   \"Show points that price action initially breaks below support before reversing. False moves can lead to fast moves in the opposite direction (bear trap). A large arrow from below is displayed\"          \r\nfalseBearTip    =   \"Show points that price action initially breaks above resistance before reversing. False moves can lead to fast moves in the opposite direction (bull trap). A large arrow from above is displayed\"           \r\nsupPushTip      =   \"Show up candles that are detected within a support zone. Can show points support is being respected. A triangle from below is displayed\"          \r\nresPushTip      =   \"Show down candles that are detected within a resistance zone. Can show points resistance is being respected. A triangle from above is displayed\"           \r\ncurlTip         =   \"Show Bjorgum TSI 'curl' when candles are detected in the range of a key zone. Can show momentum shift at Key Levels. (Correlates to Bjorgum TSI indicator)\" \r\n\r\nrepaintTip      =   \"Wait for candles end before detecting patterns. False will show potential patterns forming before they are confirmed.\"\r\nlabelsTip       =   \"Show a label for detected candle patterns\"\r\nsBoxTip         =   \"Show a box around detected candle patterns\"\r\ndTip            =   \"Detect Doji candle patterns\"      \r\nbeTip           =   \"Detect Engulfing patterns\"     \r\nhsTip           =   \"Detect Hammers and Shooting Star patterns\"     \r\ndgTip           =   \"Detect Dragonfly Doji and Gravestone Doji patterns\"     \r\ntwTip           =   \"Detect Tweezer Top and Tweezer Bottom patterns\"     \r\nstTip           =   \"Detect Spinning Top patterns\"     \r\npcTip           =   \"Detect Piercing and Dark Cloud Cover patterns\"     \r\nbhTip           =   \"Detect Harami candle patterns\"     \r\nlsTip           =   \"Detect Long Upper Shadow and Long Lower Shadow patterns\"     \r\n\r\necWickTip       =   \"Determines if engulfing candles must engulf the wick or just the body of the preceding candle\"     \r\ncolorMatchTip   =   \"Determines if hammers must be up candles and shooting stars must be down candles\"     \r\ncloseHalfTip    =   \"Determines if Tweezer patterns must close beyond the half way point of the preceding candle\"     \r\natrMaxTip       =   \"Maximum size of setup candles (as a multiplier of the current ATR)\"     \r\nrejectWickTip   =   \"The maximum wick size as a percentage of body size allowable for a rejection wick on the resolution candle of the pattern. 0 disables the filter\"\r\nhammerFibTip    =   \"The relationship of body to candle size for hammers and stars. (ie. body is 33% of total candle size).\"     \r\nhsShadowPercTip =   \"The maximum allowable opposing wick size as a percent of body size (ex. top wick for a hammer pattern etc.)\"     \r\nhammerSizeTip   =   \"The minimum size of hammers, stars, or long shadows as a multiplier of ATR. (To filter out tiny setups)\"     \r\ndojiSizeTip     =   \"The relationship of body to candle size (ie. body is 5% of total candle size).\"     \r\ndojiWickSizeTip =   \"Maximum wick size comparative to the opposite wick. (eg. 2 = bottom wick must be less than or equal to 2x the top wick).\"     \r\nluRatioTip      =   \"A relationship of the upper wick to the overall candle size expressed as a percent.\"     \r\n\r\nlookbackTip     =   \"Number of candles that can be included in a false break signal\"        \r\nswingTip        =   \"Swing detection is used to filter signals on breakout type signals. A higher number will mean more significant points, but less of them\"        \r\nreflectTip      =   \"Filter to ensure a setup is a significant swing point. Look back this far\"\r\noffsetTip       =   \"Candle pattern high/low distance from absolute swing high/low. Example: 0 would filter patterns that are only the highest/lowest, 1 filters second highest over the significant length, etc.\"\r\n\r\nbullPivotTip    =   \"Color of bullish Key Levels\\n(border, background)\"            \r\nbearPivotTip    =   \"Color of bearish Key Levels\\n(border, background)\"            \r\nbreakoutTip     =   \"Color of breakout arrows\\n(bull, bear,)\"           \r\nSnRTip          =   \"Color of triangles for broken support or resistance\\n(bull, bear)\"   \r\nfalseBreakTip   =   \"Color of arrows for false breaks\\n(bull, bear, arrow max height in pixels)\"            \r\nmoveTip         =   \"Color of triangles for candles that are detected within zones\\n(bull, bear)\"    \r\npatTip          =   \"Color of boxes that wrap candestick patterns\\nBackgrounds: (bull, neutral, bear)\\nBorders: (bull, neutral, bear)\"    \r\nlabTip          =   \"Color of labels that mark candestick patterns\\nText: (bull, neutral, bear)\\nLabels: (bull, neutral, bear)\"    \r\nstratTip        =   \"TSI speed control presets. Both speeds correlate to the Bjorgum TSI indicator\"\r\n\r\n// ================================== //\r\n// ---------> User Input <----------- //\r\n// ================================== //\r\n\r\nleft            =   input.int       (20     ,   \"Look Left\"                     ,   group= \"Zones\"                , tooltip= leftTip            )    \r\nright           =   input.int       (15     ,   \"Look Right\"                    ,   group= \"Zones\"                , tooltip= rightTip           )    \r\nnPiv            =   input.int       (4      ,   \"Number of Pivots\"              ,   group= \"Zones\"                , tooltip= nPivTip            )\r\natrLen          =   input.int       (30     ,   \"ATR Length\"                    ,   group= \"Zones\"                , tooltip= atrLenTip          )\r\nmult            =   input.float     (0.5    ,   \"Zone Width (ATR)\"              ,   group= \"Zones\"                , tooltip= multTip            ,   step   = 0.1)\r\nper             =   input.float     (5      ,   \"Max Zone Percent\"              ,   group= \"Zones\"                , tooltip= perTip             )\r\nmax             =   input.float     (10     ,   \"Max Boxes for Patterns\"        ,   group= \"Zones\"                , tooltip= maxTip             )\r\nfut             =   input.int       (30     ,   \"Offset For Labels\"             ,   group= \"Zones\"                , tooltip= futTip             )\r\nsrc             =   input.string    (\"HA\"   ,   \"Source For Pivots\"             ,   group= \"Zones\"                , tooltip= srcTip             ,   options= [\"HA\", \"High/Low Body\", \"High/Low\"])\r\nalignZones      =   input.bool      (true   ,   \"Align Zones\"                   ,   group= \"Zones\"                , tooltip= alignZonesTip      )\r\nextend          =   input.bool      (false  ,   \"Extend Right\"                  ,   group= \"Zones\"                , tooltip= extendTip          )\r\nlLab            =   input.bool      (false  ,   \"Show Level Labels\"             ,   group= \"Zones\"                , tooltip= lLabTip            )\r\n\r\ndhighs          =   input.bool      (true   ,   \"Detect Pivot Highs\"            ,   group= \"Detection\"            , tooltip= dhighsTip          )\r\ndlows           =   input.bool      (true   ,   \"Detect Pivot Lows\"             ,   group= \"Detection\"            , tooltip= dlowsTip           )\r\ndetectBO        =   input.bool      (false  ,   \"Detect Breakout\"               ,   group= \"Detection\"            , tooltip= detectBOTip        )\r\ndetectBD        =   input.bool      (false  ,   \"Detect Breakdown\"              ,   group= \"Detection\"            , tooltip= detectBDTip        )\r\nbreakUp         =   input.bool      (false  ,   \"Detect Resistance Break\"       ,   group= \"Detection\"            , tooltip= breakUpTip         )\r\nbreakDn         =   input.bool      (false  ,   \"Detect Support Break\"          ,   group= \"Detection\"            , tooltip= breakDnTip         ) \r\nfalseBull       =   input.bool      (false  ,   \"Detect False Breakdown\"        ,   group= \"Detection\"            , tooltip= falseBullTip       )\r\nfalseBear       =   input.bool      (false  ,   \"Detect False Breakup\"          ,   group= \"Detection\"            , tooltip= falseBearTip       ) \r\nsupPush         =   input.bool      (false  ,   \"Detect Moves Off Support\"      ,   group= \"Detection\"            , tooltip= supPushTip         )\r\nresPush         =   input.bool      (false  ,   \"Detect Moves Off Resistance\"   ,   group= \"Detection\"            , tooltip= resPushTip         ) \r\ncurl            =   input.bool      (false  ,   \"Detect TSI Curl\"               ,   group= \"Detection\"            , tooltip= curlTip            ) \r\n\r\nrepaint         =   input.bool      (true   ,   \"Wait For Confirmed Bar\"        ,   group= \"Candle Patterns\"      , tooltip= repaintTip         )\r\nlabels          =   input.bool      (false  ,   \"Show Label\"                    ,   group= \"Candle Patterns\"      , tooltip= labelsTip          )\r\nsBox            =   input.bool      (false  ,   \"Show Boxes Around Patterns\"    ,   group= \"Candle Patterns\"      , tooltip= sBoxTip            )\r\nd_              =   input.bool      (false  ,   \"Detect Doji\"                   ,   group= \"Candle Patterns\"      , tooltip= dTip               )\r\nbe_             =   input.bool      (false  ,   \"Detect Engulfing\"              ,   group= \"Candle Patterns\"      , tooltip= beTip              )\r\nhs_             =   input.bool      (false  ,   \"Detect Hammers and Stars\"      ,   group= \"Candle Patterns\"      , tooltip= hsTip              )\r\ndg_             =   input.bool      (false  ,   \"Detect Dragons and Graves\"     ,   group= \"Candle Patterns\"      , tooltip= dgTip              )\r\ntw_             =   input.bool      (false  ,   \"Detect Tweezers\"               ,   group= \"Candle Patterns\"      , tooltip= twTip              )\r\nst_             =   input.bool      (false  ,   \"Detect Spinning Top\"           ,   group= \"Candle Patterns\"      , tooltip= stTip              )\r\npc_             =   input.bool      (false  ,   \"Detect Piercing and Clouds\"    ,   group= \"Candle Patterns\"      , tooltip= pcTip              )\r\nbh_             =   input.bool      (false  ,   \"Detect Harami\"                 ,   group= \"Candle Patterns\"      , tooltip= bhTip              )\r\nls_             =   input.bool      (false  ,   \"Detect Long Shadows\"           ,   group= \"Candle Patterns\"      , tooltip= lsTip              )\r\n\r\nalertMode       =   input.string    (alert.freq_once_per_bar_close              ,   \"Alerts Mode\"                 , group  = \"Alert Frequency\"  ,   options= [alert.freq_once_per_bar, alert.freq_once_per_bar_close]) \r\n\r\necWick          =   input.bool      (false  ,   \"Engulfing Must Engulf Wick\"    ,   group= \"Candle Filters\"       , tooltip= ecWickTip          )\r\ncolorMatch      =   input.bool      (false  ,   \"H&S Must Match Color\"          ,   group= \"Candle Filters\"       , tooltip= colorMatchTip      )\r\ncloseHalf       =   input.bool      (false  ,   \"Tweezer Close Over Half\"       ,   group= \"Candle Filters\"       , tooltip= closeHalfTip       )\r\natrMax          =   input.float     (0.0    ,   \"Max Candle Size (× ATR)\"       ,   group= \"Candle Filters\"       , tooltip= atrMaxTip          ,   step= 0.1 )\r\nrejectWickMax   =   input.float     (0.0    ,   \"[EC] Max Reject Wick Size\"     ,   group= \"Candle Filters\"       , tooltip= rejectWickTip      ,   step= 1   )  \r\nhammerFib       =   input.float     (33     ,   \"[HS] H&S Ratio (%)\"            ,   group= \"Candle Filters\"       , tooltip= hammerFibTip       ,   step= 1   ) \r\nhsShadowPerc    =   input.float     (5      ,   \"[HS] H&S Opposing Shadow (%)\"  ,   group= \"Candle Filters\"       , tooltip= hsShadowPercTip    ,   step= 1   ) \r\nhammerSize      =   input.float     (0.1    ,   \"[HS] H&S Min Size (× ATR)\"     ,   group= \"Candle Filters\"       , tooltip= hammerSizeTip      ,   step= 0.1 ) \r\ndojiSize        =   input.float     (5      ,   \"[DJ] Doji Size (%)\"            ,   group= \"Candle Filters\"       , tooltip= dojiSizeTip        ,   step= 1   )\r\ndojiWickSize    =   input.float     (2      ,   \"[DJ] Max Doji Wick Size\"       ,   group= \"Candle Filters\"       , tooltip= dojiWickSizeTip    ,   step= 1   )\r\nluRatio         =   input.float     (75     ,   \"[LS] Long Shadow (%)\"          ,   group= \"Candle Filters\"       , tooltip= luRatioTip         ,   step= 1   ) \r\n\r\nlookback        =   input.int       (2      ,   \"Lookback For Breaks\"           ,   group= \"Lookback\"             , tooltip= lookbackTip        )\r\nswing           =   input.int       (5      ,   \"swing High/Low\"                ,   group= \"Lookback\"             , tooltip= swingTip           )\r\nreflect         =   input.int       (10     ,   \"Significant High/Low\"          ,   group= \"Lookback\"             , tooltip= reflectTip         )\r\noffset          =   input.int       (1      ,   \"Consider Bar From High/Low\"    ,   group= \"Lookback\"             , tooltip= offsetTip          )\r\n\r\nbullBorder      =   input.color     (color.new  (#64b5f6, 60), \"\", inline= \"0\"  ,   group= \"Pivot Color\"                                        )\r\nbullBgCol       =   input.color     (color.new  (#64b5f6, 95), \"\", inline= \"0\"  ,   group= \"Pivot Color\"          , tooltip= bullPivotTip       )\r\nbearBorder      =   input.color     (color.new  (#ffeb3b, 60), \"\", inline= \"1\"  ,   group= \"Pivot Color\"                                        )   \r\nbearBgCol       =   input.color     (color.new  (#ffeb3b, 95), \"\", inline= \"1\"  ,   group= \"Pivot Color\"          , tooltip= bearPivotTip       )\r\n\r\nupCol           =   input.color     (color.new  (#ff6d00, 25), \"\", inline= \"2\"  ,   group= \"Breakout Color\"                                     )\r\ndnCol           =   input.color     (color.new  (#ff00ff, 25), \"\", inline= \"2\"  ,   group= \"Breakout Color\"       , tooltip= breakoutTip        ) \r\n\r\nsupCol          =   input.color     (color.new  (#17ff00, 25), \"\", inline= \"3\"  ,   group= \"S&R Break Color\"                                    )\r\nresCol          =   input.color     (color.new  (#ff0000, 25), \"\", inline= \"3\"  ,   group= \"S&R Break Color\"      , tooltip= SnRTip             ) \r\n\r\nfBull           =   input.color     (color.new  (#17ff00, 25), \"\", inline= \"4\"  ,   group= \"False Break Color\"                                  )\r\nfBear           =   input.color     (color.new  (#ff0000, 25), \"\", inline= \"4\"  ,   group= \"False Break Color\"                                  )\r\narrowMax        =   input.int       (75                      , \"\", inline= \"4\"  ,   group= \"False Break Color\"    , tooltip= falseBreakTip      )\r\n\r\nmoveBullCol     =   input.color     (color.new  (#64b5f6, 25), \"\", inline= \"5\"  ,   group= \"Moves From S&R Color\"                               )\r\nmoveBearCol     =   input.color     (color.new  (#ffeb3b, 25), \"\", inline= \"5\"  ,   group= \"Moves From S&R Color\" , tooltip= moveTip            ) \r\n\r\ncurlBullCol     =   input.color     (color.new  (#17ff00, 40), \"\", inline= \"6\"  ,   group= \"Momentum Curl Color\"                                )\r\ncurlBearCol     =   input.color     (color.new  (#f3ff00, 40), \"\", inline= \"6\"  ,   group= \"Momentum Curl Color\"  , tooltip= curlTip            ) \r\n\r\npatBullBg       =   input.color     (color.new  (#17ff00, 90), \"\", inline= \"7\"  ,   group= \"Pattern Box Color\"                                  )\r\npatNeutBg       =   input.color     (color.new  (#b2b5be, 90), \"\", inline= \"7\"  ,   group= \"Pattern Box Color\"                                  )\r\npatBearBg       =   input.color     (color.new  (#ff0000, 90), \"\", inline= \"7\"  ,   group= \"Pattern Box Color\"                                  )\r\npatBullBo       =   input.color     (color.new  (#17ff00, 80), \"\", inline= \"8\"  ,   group= \"Pattern Box Color\"                                  )\r\npatNeutBo       =   input.color     (color.new  (#b2b5be, 80), \"\", inline= \"8\"  ,   group= \"Pattern Box Color\"                                  )\r\npatBearBo       =   input.color     (color.new  (#ff0000, 80), \"\", inline= \"8\"  ,   group= \"Pattern Box Color\"    , tooltip= patTip             ) \r\n\r\ntextBullCol     =   input.color     (color.new  (#17ff00,  0), \"\", inline= \"9\"  ,   group= \"Label Color (Text/Bg)\"                              )\r\ntextNeutCol     =   input.color     (color.new  (#b2b5be,  0), \"\", inline= \"9\"  ,   group= \"Label Color (Text/Bg)\"                              )\r\ntextBearCol     =   input.color     (color.new  (#ff0000,  0), \"\", inline= \"9\"  ,   group= \"Label Color (Text/Bg)\"                              )\r\nlabBullCol      =   input.color     (color.new  (#17ff00, 80), \"\", inline= \"10\" ,   group= \"Label Color (Text/Bg)\"                              )\r\nlabNeutCol      =   input.color     (color.new  (#b2b5be, 80), \"\", inline= \"10\" ,   group= \"Label Color (Text/Bg)\"                              )\r\nlabBearCol      =   input.color     (color.new  (#ff0000, 80), \"\", inline= \"10\" ,   group= \"Label Color (Text/Bg)\", tooltip= labTip             ) \r\n\r\nstrat           =   input.string    (\"Fast\" ,   \"Select a Speed\"                ,   group= \"TSI Speed Control\"    , tooltip= stratTip           ,   options= [\"Fast\", \"Slow\"])\r\n    \r\nlongf           =   input.int       (25     ,   \"Long Length\"                   ,   group= \"TSI Fast Settings\"                                  )\r\nshortf          =   input.int       (5      ,   \"Short Length\"                  ,   group= \"TSI Fast Settings\"                                  )\r\nsignalf         =   input.int       (14     ,   \"Signal Length\"                 ,   group= \"TSI Fast Settings\"                                  )\r\n\r\nlongs           =   input.int       (25     ,   \"Long Length\"                   ,   group= \"TSI Slow Settings\"                                  )\r\nshorts          =   input.int       (13     ,   \"Short Length\"                  ,   group= \"TSI Slow Settings\"                                  )\r\nsignals         =   input.int       (13     ,   \"Signal Length\"                 ,   group= \"TSI Slow Settings\"                                  )\r\n\r\n// ================================== //\r\n// -----> Immutable Constants <------ //\r\n// ================================== //    \r\n \r\nsync            =   bar_index\r\nlabUp           =   label.style_label_up\r\nlabDn           =   label.style_label_down\r\nconfirmed       =   barstate.isconfirmed\r\nextrap          =   extend ?        extend.right  : extend.none\r\n\r\nvar pivotHigh   =   array.new_box   (nPiv)\r\nvar pivotLows   =   array.new_box   (nPiv)  \r\nvar highBull    =   array.new_bool  (nPiv)\r\nvar lowsBull    =   array.new_bool  (nPiv)\r\nvar boxes       =   array.new_box   ()\r\n\r\nhaSrc           =   src    ==       \"HA\"    \r\nhiLoSrc         =   src    ==       \"High/Low\"\r\ntsifast         =   strat  ==       \"Fast\"\r\ntsislow         =   strat  ==       \"Slow\"\r\n\r\n// ================================== //\r\n// ---> Functional Declarations <---- //\r\n// ================================== //\r\n\r\natr             =   ta.atr          (atrLen)\r\nperMax          =   close*          0.02\r\nmin             =   math.min        (perMax, atr*0.3)\r\n\r\n_haBody()       =>\r\n    haClose     =   (open + high  +  low  + close)    / 4\r\n    haOpen      =   float(na)\r\n    haOpen      :=  na(haOpen[1]) ? (open + close)    / 2 : \r\n                   (nz(haOpen[1]) + nz(haClose[1]))   / 2\r\n    \r\n    [haOpen, haClose]\r\n    \r\n_extend(_x) =>\r\n    for i = 0 to               array.size       (_x)-1\r\n        box.set_right          (array.get       (_x, i), sync)\r\n        \r\n_arrayLoad(_x, _max, _val) =>  \r\n    array.unshift                               (_x,   _val)   \r\n    if  array.size                              (_x) > _max\r\n        array.pop                               (_x)\r\n\r\n_arrayBox(_x, _max, _val) =>  \r\n    array.unshift                               (_x,   _val)   \r\n    if       array.size                         (_x) > _max\r\n        _b = array.pop                          (_x)\r\n        if extend\r\n            box.set_extend                      (_b, extend.none)\r\n\r\n_arrayWrap(_x, _max, _val) =>  \r\n    array.unshift                               (_x,   _val)   \r\n    if  array.size                              (_x) > _max\r\n        box.delete(array.pop                    (_x))\r\n\r\n_delLab(_x)     =>\r\n    if array.size(_x) > 0 \r\n        label.delete           (array.pop       (_x))\r\n\r\n_delLine(_x)    =>\r\n    if array.size(_x) > 0 \r\n        line.delete            (array.pop       (_x))\r\n\r\n_delLevels(_x, _y)  =>\r\n    for i = 0 to array.size                     (_x)-1\r\n        _delLab                                 (_x)\r\n        _delLine                                (_y)\r\n\r\n_box(_x1, _t, _r, _b, _boCol, _bgCol, _e) =>\r\n    box.new(                   _x1, _t, _r, _b  , \r\n     xloc        =             xloc.bar_index   ,\r\n     extend      =             _e               ,\r\n     border_color=             _boCol           ,   \r\n     bgcolor     =             _bgCol           ) \r\n\r\n_wrap(_cond, _x, _bb, _bc, _bgc) =>\r\n    _t           =             ta.highest       (high, _bb) + min\r\n    _b           =             ta.lowest        (low , _bb) - min\r\n    _l           =             bar_index -      _bb\r\n    _r           =             bar_index +      1\r\n    if  _cond\r\n        _arrayWrap            (_x, max, _box    (_l, _t, _r, _b, _bc, _bgc, extend.none)) \r\n\r\n_getBox(_x,_i)   =>\r\n    _box         =             array.get        (_x,_i)\r\n    _t           =             box.get_top      (_box)\r\n    _b           =             box.get_bottom   (_box)\r\n    [_t, _b]\r\n    \r\n_align(_x,_y)    =>\r\n    for i = 0 to               array.size       (_x) -1\r\n        [_T, _B] =             _getBox          (_y, 0)\r\n        [_t, _b] =             _getBox          (_x, i)\r\n        if _T > _b and         _T < _t or \r\n           _B < _t and         _B > _b or \r\n           _T > _t and         _B < _b or \r\n           _B > _b and         _T < _t\r\n            box.set_top        (array.get       (_y, 0), _t)\r\n            box.set_bottom     (array.get       (_y, 0), _b)\r\n \r\n_color(_x, _y)     =>\r\n    var int _track = nPiv\r\n    for i = 0 to               array.size       (_x) -1\r\n        [t_, b_] =             _getBox          (_x, i)\r\n        _isBull  =             array.get        (_y, i)\r\n        if close > t_ and not  _isBull\r\n            box.set_extend(    array.get        (_x, i), extend.none)\r\n            array.set(_x, i,   _box             (sync  , t_, sync, b_, bullBorder, bullBgCol, extrap))\r\n            array.set(_y, i,   true)\r\n            _track += 1\r\n        if close < b_ and _isBull\r\n            box.set_extend(    array.get        (_x, i), extend.none)\r\n            array.set(_x, i,   _box             (sync  , t_, sync, b_, bearBorder, bearBgCol, extrap))\r\n            array.set(_y, i,   false)\r\n            _track -= 1\r\n    _track\r\n\r\n_detect(_x,_y)      =>\r\n    int  _i         = 0\r\n    bool _found     = false\r\n    bool _isBull    = na\r\n    while (not _found and _i < array.size       (_x)  )\r\n        [t_, b_] =             _getBox          (_x,_i)\r\n        if low < t_ and high > b_\r\n            _isBull :=         array.get        (_y,_i)\r\n            _found  :=         true\r\n        _i          +=         1\r\n    [_found, _isBull]\r\n\r\n_falseBreak(_l)     =>       \r\n    bool _d         = false\r\n    bool _u         = false\r\n    for i = 1 to lookback\r\n        if _l[i] < _l and _l[i+1] >= _l and _l[1] < _l \r\n            _d      := true\r\n        if _l[i] > _l and _l[i+1] <= _l and _l[1] > _l \r\n            _u      := true\r\n    [_d, _u]\r\n\r\n_numLevel(_x,_y)    =>\r\n    int _above      = 0\r\n    int _fill       = 0\r\n    for i = 0 to               array.size       (_x)-1\r\n        _isBull     =          array.get        (_x,i)\r\n        if  _isBull\r\n            _above += 1\r\n        if  not na(_isBull)\r\n            _fill  += 1\r\n    for i = 0 to               array.size       (_y)-1\r\n        _isBull     =          array.get        (_y,i)\r\n        if  _isBull\r\n            _above += 1\r\n        if  not na(_isBull)\r\n            _fill  += 1\r\n    [_above, _fill]  \r\n\r\n_check(_src,_l)     =>\r\n    bool _check     = false\r\n    for i = 0 to _l\r\n        if _src[i]\r\n            _check := true\r\n    _check\r\n\r\n_count(_src, _l)    =>\r\n    int _result     = 0\r\n    for i = 0 to _l\r\n        if _src > _src[i]\r\n            _result += 1\r\n    _result\r\n\r\n_label(_x, _y, y, _s, _col1, _col2) =>\r\n    transp = math.min   (color.t(_col1),  color.t(_col2))\r\n    array.unshift       (_x,   label.new (sync+fut,   y                                        , \r\n                                          text      = str.tostring(math.round_to_mintick(y)   ), \r\n                                          color     = color.new(_col1, transp)                 , \r\n                                          style     = _s                                       , \r\n                                          textcolor = color.white                             ))\r\n    if not extend and fut > 0\r\n        array.unshift   (_y,   line.new  (sync, y, sync+fut, y, color= color.new(_col1, transp)))\r\n\r\n_level(_x, _y)          =>\r\n    var label [] lab    =      array.new_label  (nPiv)\r\n    var line  [] lines  =      array.new_line   (nPiv)\r\n    if barstate.islast and lLab\r\n        _delLevels             (lab, lines)\r\n        for i = 0 to           array.size       (_x)-1\r\n            [_t, _b]    =      _getBox          (_x,i)\r\n            _isBull     =      array.get        (_y,i)\r\n            _col1        =     _isBull ?        bullBgCol  : bearBgCol\r\n            _col2        =     _isBull ?        bullBorder : bearBorder\r\n            if close >  _t \r\n                _label  (lab, lines, _t, labUp, _col1, _col2)\r\n            if close <  _b \r\n                _label  (lab, lines, _b, labDn, _col1, _col2)\r\n            if close <  _t and close >   _b\r\n                _label  (lab, lines, _t, labDn, _col1, _col2)\r\n                _label  (lab, lines, _b, labUp, _col1, _col2)\r\n\r\n_alert(_x, _y) =>\r\n    if _x\r\n        alert   (_y + timeframe.period + ' chart. Price is ' + str.tostring(close), alertMode)\r\n        \r\n// ================================== //\r\n// ----> Variable Calculations <----- //\r\n// ================================== //\r\n\r\nshortvar        =   tsifast ?           shortf  :       shorts   \r\nlongvar         =   tsifast ?           longf   :       longs    \r\nsignalvar       =   tsifast ?           signalf :       signals \r\n\r\ntsi             =   ta.tsi              (close,         shortvar,   longvar)\r\ntsl             =   ta.ema              (tsi,           signalvar)\r\n\r\nhighest         =   close ==            ta.highest      (close,     right)\r\nlowest          =   close ==            ta.lowest       (close,     right)\r\n\r\ncloseLows       =   ta.lowest           (close,         swing)\r\ncloseHigh       =   ta.highest          (close,         swing)\r\n\r\nnumLows         =   _count              (low,           reflect)\r\nnumHigh         =   _count              (high,          reflect)\r\n\r\n[open_, close_] =   _haBody             ()\r\n\r\nhiHaBod         =   math.max            (close_,        open_)\r\nloHaBod         =   math.min            (close_,        open_)\r\n\r\nhiBod           =   math.max            (close,         open)\r\nloBod           =   math.min            (close,         open)\r\n\r\nsrcHigh         =   haSrc ?             hiHaBod :       hiLoSrc ?   high :      hiBod\r\nsrcLow          =   haSrc ?             loHaBod :       hiLoSrc ?   low  :      loBod\r\n\r\npivot_high      =   ta.pivothigh        (srcHigh,       left,       right)\r\npivot_low       =   ta.pivotlow         (srcLow,        left,       right)\r\n\r\nperc            =   close*              (per/100)\r\n\r\nband            =   math.min            (atr*mult,      perc)       [right]     /2\r\n\r\nHH              =   pivot_high+         band\r\nHL              =   pivot_high-         band\r\n\r\nLH              =   pivot_low+          band\r\nLL              =   pivot_low-          band\r\n\r\ncoDiff          =   close -             open\r\n\r\n// ================================== //\r\n// --------> Logical Order <--------- //\r\n// ================================== //\r\n\r\nif pivot_high and   dhighs and  confirmed\r\n    _arrayLoad      (highBull , nPiv,   false)      \r\n    _arrayBox       (pivotHigh, nPiv,   _box(sync[right], HH, sync, HL, bearBorder, bearBgCol, extrap))\r\n\r\nif pivot_low  and   dlows and   confirmed\r\n    _arrayLoad      (lowsBull , nPiv,   true)      \r\n    _arrayBox       (pivotLows, nPiv,   _box(sync[right], LH, sync, LL, bullBorder, bullBgCol, extrap))\r\n\r\nif alignZones\r\n    _align          (pivotHigh,         pivotHigh)\r\n    _align          (pivotHigh,         pivotLows)    \r\n    _align          (pivotLows,         pivotLows)\r\n    _align          (pivotLows,         pivotHigh)\r\n\r\n_extend             (pivotHigh)\r\n_extend             (pivotLows)\r\n\r\ntrackHigh       =   _color              (pivotHigh,     highBull)\r\ntrackLows       =   _color              (pivotLows,     lowsBull)\r\n\r\n// ================================== //\r\n// ----> Conditional Parameters <---- //\r\n// ================================== //\r\n\r\nisLows          =   closeLows      ==   close\r\nisHigh          =   closeHigh      ==   close\r\n\r\nwasLows         =   _check              (isLows,        lookback)\r\nwasHigh         =   _check              (isHigh,        lookback)\r\n\r\n[above, total]  =   _numLevel           (highBull,      lowsBull)\r\n\r\nmoveAbove       =   trackHigh       >   trackHigh[1]\r\nmoveBelow       =   trackLows       <   trackLows[1]\r\n\r\nresBreak        =   (trackLows      >   trackLows[1]    or  moveAbove) \r\nsupBreak        =   (trackHigh      <   trackHigh[1]    or  moveBelow) \r\n\r\nbreakOut        =   moveAbove     and   highest and     above == total             \r\nbreakDwn        =   moveBelow     and   lowest  and     above == 0         \r\n\r\n[dh, uh]        =   _falseBreak         (trackHigh) \r\n[dl, ul]        =   _falseBreak         (trackLows) \r\n\r\nfalseBreakBull  =   wasLows       and   (dh or dl)\r\nfalseBreakBear  =   wasHigh       and   (uh or ul)\r\n\r\n[fh,hb]         =   _detect             (pivotHigh,     highBull)\r\n[fl,lb]         =   _detect             (pivotLows,     lowsBull)\r\n\r\nbull            =   (fh or fl) and      (hb or lb)\r\nbear            =   (fh or fl) and not  (hb or lb)\r\n\r\nbullCheck       =   not resBreak  and   not resBreak[1] and (fh or fl) and  close > open and     (hb or lb)\r\nbearCheck       =   not supBreak  and   not supBreak[1] and (fh or fl) and  close < open and not (hb or lb)\r\n\r\nhighrange       =   reflect-offset\r\nlowsrange       =   offset\r\n\r\nsigLows         =   numLows        <=   lowsrange  \r\nsigHigh         =   numHigh        >=   highrange \r\n\r\nisBull1         =   sigLows       and   bull\r\nisBear1         =   sigHigh       and   bear \r\n\r\nisBull2         =   (sigLows       or   sigLows[1]) and         (bull or bull[1])\r\nisBear2         =   (sigHigh       or   sigHigh[1]) and         (bear or bear[1])\r\n\r\ndata            =   tsi > tsi[1]  and   tsi < tsl \r\ndtat            =   tsi < tsi[1]  and   tsi > tsl \r\n\r\nhMatch          =   not colorMatch or   close > open\r\nsMatch          =   not colorMatch or   close < open\r\n\r\nhsFilter        =   bj.barRange()  >=   hammerSize * atr\r\natrMaxSize      =   bj.barRange()  <=   atrMax     * atr or     atrMax == 0.0\r\n\r\nrp              =   confirmed  or not   repaint\r\n\r\n// ================================== //\r\n// -----> Pattern Recognition <------ //\r\n// ================================== //\r\n\r\ndw              =   isBull1 and rp and d_  and atrMaxSize and bj.doji              (dojiSize           = dojiSize,         dojiWickSize    = dojiWickSize)\r\ndb              =   isBear1 and rp and d_  and atrMaxSize and bj.doji              (dojiSize           = dojiSize,         dojiWickSize    = dojiWickSize)\r\nbew             =   isBull2 and rp and be_ and atrMaxSize and bj.bullEngulf        (maxRejectWick      = rejectWickMax,    mustEngulfWick  = ecWick) \r\nbeb             =   isBear2 and rp and be_ and atrMaxSize and bj.bearEngulf        (maxRejectWick      = rejectWickMax,    mustEngulfWick  = ecWick)\r\nh               =   isBull1 and rp and hs_ and atrMaxSize and bj.hammer            (ratio              = hammerFib,        shadowPercent   = hsShadowPerc) and hsFilter and hMatch\r\nss              =   isBear1 and rp and hs_ and atrMaxSize and bj.star              (ratio              = hammerFib,        shadowPercent   = hsShadowPerc) and hsFilter and sMatch\r\ndd              =   isBull1 and rp and dg_ and atrMaxSize and bj.dragonflyDoji     ()\r\ngd              =   isBear1 and rp and dg_ and atrMaxSize and bj.gravestoneDoji    ()\r\ntb              =   isBull2 and rp and tw_ and atrMaxSize and bj.tweezerBottom     (closeUpperHalf     = closeHalf)\r\ntt              =   isBear2 and rp and tw_ and atrMaxSize and bj.tweezerTop        (closeLowerHalf     = closeHalf)\r\nstw             =   isBull1 and rp and st_ and atrMaxSize and bj.spinningTop       ()\r\nstb             =   isBear1 and rp and st_ and atrMaxSize and bj.spinningTop       ()\r\np               =   isBull1 and rp and pc_ and atrMaxSize and bj.piercing          ()\r\ndcc             =   isBear1 and rp and pc_ and atrMaxSize and bj.darkCloudCover    ()\r\nbhw             =   isBull1 and rp and bh_ and atrMaxSize and bj.haramiBull        ()  \r\nbhb             =   isBear1 and rp and bh_ and atrMaxSize and bj.haramiBear        ()\r\nll              =   isBull1 and rp and ls_ and atrMaxSize and bj.lls               (ratio              = luRatio)          and hsFilter\r\nlu              =   isBear1 and rp and ls_ and atrMaxSize and bj.lus               (ratio              = luRatio)          and hsFilter\r\n\r\n// ================================== //\r\n// ------> Graphical Display <------- //\r\n// ================================== //\r\n\r\nplotFalseDn     =   falseBull     and   falseBreakBull\r\nplotFalseUp     =   falseBear     and   falseBreakBear\r\n\r\nfalseUpCol      =   plotFalseUp     ?   upCol       :   na\r\nfalseDnCol      =   plotFalseDn     ?   dnCol       :   na\r\n\r\nplotBreakOut    =   breakOut      and   detectBO    and not     plotFalseDn\r\nplotBreakDn     =   breakDwn      and   detectBD    and not     plotFalseUp\r\n\r\nplotResBreak    =   resBreak      and   breakUp     and not     (plotBreakOut or plotFalseDn)\r\nplotSupBreak    =   supBreak      and   breakDn     and not     (plotBreakDn  or plotFalseUp)\r\n\r\nplotBullCheck   =   bullCheck     and   supPush\r\nplotBearCheck   =   bearCheck     and   resPush\r\n\r\nplotCurlBull    =   curl and data and   bull\r\nplotCurlBear    =   curl and dtat and   bear\r\n\r\nplotarrow           (plotFalseUp    ?   coDiff      :   na      ,   colorup  = fBull          ,     colordown=      fBear ,         maxheight=      arrowMax)\r\nplotarrow           (plotFalseDn    ?   coDiff      :   na      ,   colorup  = fBull          ,     colordown=      fBear ,         maxheight=      arrowMax)\r\n\r\nplotshape           (plotBreakOut   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          upCol ,         size=           size.small)\r\nplotshape           (plotBreakDn    ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          dnCol ,         size=           size.small)\r\n\r\nplotshape           (plotResBreak   ,   style=shape.arrowup     ,   location=location.belowbar,     color=          supCol,         size=           size.small)\r\nplotshape           (plotSupBreak   ,   style=shape.arrowdown   ,   location=location.abovebar,     color=          resCol,         size=           size.small)\r\n\r\nplotshape           (plotBullCheck  ,   style=shape.triangleup  ,   location=location.belowbar,     color=          moveBullCol)\r\nplotshape           (plotBearCheck  ,   style=shape.triangledown,   location=location.abovebar,     color=          moveBearCol)\r\n\r\nplotshape           (plotCurlBull   ,   style=shape.triangleup  ,   location=location.belowbar,     color=          curlBullCol)\r\nplotshape           (plotCurlBear   ,   style=shape.triangledown,   location=location.abovebar,     color=          curlBearCol)\r\n\r\nbj.dLab             (dw  and labels, labNeutCol, textNeutCol), _wrap (dw  and sBox, boxes, 1, patNeutBo, patNeutBg)\r\nbj.bewLab           (bew and labels, labBullCol, textBullCol), _wrap (bew and sBox, boxes, 2, patBullBo, patBullBg)\r\nbj.hLab             (h   and labels, labBullCol, textBullCol), _wrap (h   and sBox, boxes, 1, patBullBo, patBullBg)\r\nbj.ddLab            (dd  and labels, labBullCol, textBullCol), _wrap (dd  and sBox, boxes, 1, patBullBo, patBullBg)\r\nbj.tbLab            (tb  and labels, labBullCol, textBullCol), _wrap (tb  and sBox, boxes, 2, patBullBo, patBullBg)\r\nbj.stwLab           (stw and labels, labNeutCol, textNeutCol), _wrap (stw and sBox, boxes, 1, patBullBo, patNeutBg)\r\nbj.pLab             (p   and labels, labBullCol, textBullCol), _wrap (p   and sBox, boxes, 2, patBullBo, patBullBg)\r\nbj.hwLab            (bhw and labels, labBullCol, textBullCol), _wrap (bhw and sBox, boxes, 2, patBullBo, patBullBg)\r\nbj.llsLab           (ll  and labels, labBullCol, textBullCol), _wrap (ll  and sBox, boxes, 1, patBullBo, patBullBg)\r\n\r\nbj.dLab             (db  and labels, labNeutCol, textNeutCol), _wrap (db  and sBox, boxes, 1, patNeutBo, patNeutBg)\r\nbj.bebLab           (beb and labels, labBearCol, textBearCol), _wrap (beb and sBox, boxes, 2, patBearBo, patBearBg)\r\nbj.ssLab            (ss  and labels, labBearCol, textBearCol), _wrap (ss  and sBox, boxes, 1, patBearBo, patBearBg)\r\nbj.gdLab            (gd  and labels, labBearCol, textBearCol), _wrap (gd  and sBox, boxes, 1, patBearBo, patBearBg)\r\nbj.ttLab            (tt  and labels, labBearCol, textBearCol), _wrap (tt  and sBox, boxes, 2, patBearBo, patBearBg)\r\nbj.stbLab           (stb and labels, labNeutCol, textNeutCol), _wrap (stb and sBox, boxes, 1, patBearBo, patBearBg)\r\nbj.dccLab           (dcc and labels, labBearCol, textBearCol), _wrap (dcc and sBox, boxes, 2, patBearBo, patBearBg)\r\nbj.hbLab            (bhb and labels, labBearCol, textBearCol), _wrap (bhb and sBox, boxes, 2, patBearBo, patBearBg)\r\nbj.lusLab           (lu  and labels, labBearCol, textBearCol), _wrap (lu  and sBox, boxes, 1, patBearBo, patBearBg)\r\n\r\n_level              (pivotHigh, highBull)\r\n_level              (pivotLows, lowsBull)\r\n\r\n// ================================== //\r\n// -----> Alert Functionality <------ //\r\n// ================================== //\r\n\r\nalertcondition      (resBreak       ,   'Resistance break'                      ,   'Resistance broke on {{interval}} chart. Price is {{close}}'                    )\r\nalertcondition      (supBreak       ,   'Support break'                         ,   'Support broke on {{interval}} chart. Price is {{close}}'                       )\r\nalertcondition      (bullCheck      ,   'Found support'                         ,   'Pushing Off Key Level Support on {{interval}} chart. Price is {{close}}'       )\r\nalertcondition      (bearCheck      ,   'Found resistance'                      ,   'Pushing Off Key Level Resistance on {{interval}} chart. Price is {{close}}'    )\r\nalertcondition      (falseBreakBull ,   'False break down'                      ,   'False Break Down on {{interval}} chart. Price is {{close}}'                    )\r\nalertcondition      (falseBreakBear ,   'False break up'                        ,   'False Break Up on {{interval}} chart. Price is {{close}}'                      )\r\nalertcondition      (breakOut       ,   'Breakout'                              ,   'Breakout on {{interval}} chart. Price is {{close}}'                            )\r\nalertcondition      (breakDwn       ,   'Breakdown'                             ,   'Breakdown on {{interval}} chart. Price is {{close}}'                           )\r\n\r\n_alert              (plotResBreak   ,   'Resistance broke on '                  )\r\n_alert              (plotSupBreak   ,   'Support break '                        )\r\n_alert              (plotBullCheck  ,   'Pushing off key level support on '     )\r\n_alert              (plotBearCheck  ,   'Pushing off key level resistance on '  )\r\n_alert              (plotFalseDn    ,   'False break down on '                  )\r\n_alert              (plotFalseUp    ,   'False break up on '                    )\r\n_alert              (plotBreakOut   ,   'Breakout on '                          )\r\n_alert              (plotBreakDn    ,   'Breakdown on '                         )\r\n\r\n_alert              (dw             ,   'Doji at support on '                   )\r\n_alert              (db             ,   'Doji at resistance on '                )\r\n_alert              (bew            ,   'Bullish Engulfing on '                 )\r\n_alert              (beb            ,   'Bearish Engulfing on '                 )\r\n_alert              (h              ,   'Hammer candle on '                     )\r\n_alert              (ss             ,   'Shooting star on '                     )\r\n_alert              (dd             ,   'Dragonfly Doji on '                    )\r\n_alert              (gd             ,   'Gravestone Doji on '                   )\r\n_alert              (tb             ,   'Tweezer Bottom on '                    )\r\n_alert              (tt             ,   'Tweezer Top on '                       )\r\n_alert              (stw            ,   'White Spinning Top on '                )\r\n_alert              (stb            ,   'Black Spinning Top on '                )\r\n_alert              (p              ,   'Piercing on '                          )\r\n_alert              (dcc            ,   'Dark Cloud Cover on '                  )\r\n_alert              (bhw            ,   'Bullish Harami on '                    )\r\n_alert              (bhb            ,   'Bearish Harami on '                    )\r\n_alert              (ll             ,   'Long Lower Shadow on '                 )\r\n_alert              (lu             ,   'Long Upper Shadow on '                 )\r\n\r\n//  ____  __ _  ____ \r\n// (  __)(  ( \\(    \\\r\n//  ) _) /    / ) D (\r\n// (____)\\_)__)(____/\r\n","updated":"2022-02-26T21:26:28.334715Z","version":"12.0"}