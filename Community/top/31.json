{"created":"2021-10-04T12:26:22.493507Z","extra":{"kind":"study","sourceInputsCount":0},"lastVersionMaj":"5.0","scriptAccess":"open_no_auth","scriptName":"Support Resistance Channels","source":"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© LonesomeTheBlue\r\n \r\n//@version=4\r\nstudy(\"Support Resistance Channels\", \"SRchannel\", overlay = true, max_bars_back = 501)\r\nprd = input(defval = 10, title=\"Pivot Period\", minval = 4, maxval = 30, group = \"Settings ðŸ”¨\", tooltip=\"Used while calculating Pivot Points, checks left&right bars\")\r\nppsrc = input(defval = 'High/Low', title=\"Source\", options = ['High/Low', 'Close/Open'], group = \"Settings ðŸ”¨\", tooltip=\"Source for Pivot Points\")\r\nChannelW = input(defval = 5, title = \"Maximum Channel Width %\", minval = 1, maxval = 8, group = \"Settings ðŸ”¨\", tooltip=\"Calculated using Highest/Lowest levels in 300 bars\")\r\nminstrength = input(defval = 1, title = \"Minimum Strength\", minval = 1, group = \"Settings ðŸ”¨\", tooltip = \"Channel must contain at least 2 Pivot Points\")\r\nmaxnumsr = input(defval = 6, title = \"Maximum Number of S/R\", minval = 1, maxval = 10, group = \"Settings ðŸ”¨\", tooltip = \"Maximum number of Support/Resistance Channels to Show\") - 1\r\nloopback = input(defval = 290, title = \"Loopback Period\", minval = 100, maxval = 400, group = \"Settings ðŸ”¨\", tooltip=\"While calculating S/R levels it checks Pivots in Loopback Period\")\r\nres_col = input(defval = color.new(color.red, 75), title = \"Resistance Color\", group = \"Colors ðŸŸ¡ðŸŸ¢ðŸŸ£\")\r\nsup_col = input(defval = color.new(color.lime, 75), title = \"Support Color\", group = \"Colors ðŸŸ¡ðŸŸ¢ðŸŸ£\")\r\ninch_col = input(defval = color.new(color.gray, 75), title = \"Color When Price in Channel\", group = \"Colors ðŸŸ¡ðŸŸ¢ðŸŸ£\")\r\nshowpp = input(defval = false, title = \"Show Pivot Points\", group = \"Extras â¶â·\")\r\nshowsrbroken = input(defval = false, title = \"Show Broken Support/Resistance\", group = \"Extras â¶â·\")\r\nshowthema1en = input(defval = false, title = \"MA 1\", inline = \"ma1\")\r\nshowthema1len = input(defval = 50, title = \"\", inline = \"ma1\")\r\nshowthema1type = input(defval = \"SMA\", title = \"\", options = [\"SMA\", \"EMA\"], inline = \"ma1\")\r\nshowthema2en = input(defval = false, title = \"MA 2\", inline = \"ma2\")\r\nshowthema2len = input(defval = 200, title = \"\", inline = \"ma2\")\r\nshowthema2type = input(defval = \"SMA\", title = \"\", options = [\"SMA\", \"EMA\"], inline = \"ma2\")\r\n\r\nma1 = showthema1en ? (showthema1type == \"SMA\" ? sma(close, showthema1len) : ema(close, showthema1len)) : na\r\nma2 = showthema2en ? (showthema2type == \"SMA\" ? sma(close, showthema2len) : ema(close, showthema2len)) : na\r\n\r\nplot(ma1, color = not na(ma1) ? color.blue : na)\r\nplot(ma2, color = not na(ma2) ? color.red : na)\r\n\r\n// get Pivot High/low\r\nfloat src1 =  ppsrc == 'High/Low' ? high : max(close, open)\r\nfloat src2 =  ppsrc == 'High/Low' ? low: min(close, open)\r\nfloat ph = pivothigh(src1, prd, prd)\r\nfloat pl = pivotlow(src2, prd, prd) \r\n\r\n// draw Pivot points\r\nplotshape(ph and showpp, text = \"H\",  style = shape.labeldown, color = na, textcolor = color.red, location = location.abovebar, offset = -prd)\r\nplotshape(pl and showpp, text = \"L\",  style = shape.labelup, color = na, textcolor = color.lime, location = location.belowbar, offset = -prd)\r\n\r\n//calculate maximum S/R channel width\r\nprdhighest =  highest(300)\r\nprdlowest = lowest(300)\r\ncwidth = (prdhighest - prdlowest) * ChannelW / 100\r\n\r\n// get/keep Pivot levels\r\nvar pivotvals= array.new_float(0)\r\nvar pivotlocs= array.new_float(0)\r\nif ph or pl\r\n    array.unshift(pivotvals, ph ? ph : pl)\r\n    array.unshift(pivotlocs, bar_index)\r\n    for x = array.size(pivotvals) - 1 to 0\r\n        if bar_index - array.get(pivotlocs, x) > loopback // remove old pivot points\r\n            array.pop(pivotvals)\r\n            array.pop(pivotlocs)\r\n            continue\r\n        break\r\n\r\n//find/create SR channel of a pivot point\r\nget_sr_vals(ind)=>\r\n    float lo = array.get(pivotvals, ind)\r\n    float hi = lo\r\n    int numpp = 0\r\n    for y = 0 to array.size(pivotvals) - 1\r\n        float cpp = array.get(pivotvals, y)\r\n        float wdth = cpp <= hi ? hi - cpp : cpp - lo\r\n        if wdth <= cwidth // fits the max channel width?\r\n            if cpp <= hi\r\n                lo := min(lo, cpp)\r\n            else\r\n                hi := max(hi, cpp)\r\n                \r\n            numpp := numpp + 20 // each pivot point added as 20\r\n    [hi, lo, numpp] \r\n\r\n// keep old SR channels and calculate/sort new channels if we met new pivot point\r\nvar suportresistance = array.new_float(20, 0) // min/max levels\r\nchangeit(x, y)=>\r\n    tmp = array.get(suportresistance, y * 2)\r\n    array.set(suportresistance, y * 2, array.get(suportresistance, x * 2))\r\n    array.set(suportresistance, x * 2, tmp)\r\n    tmp := array.get(suportresistance, y * 2 + 1)\r\n    array.set(suportresistance, y * 2 + 1, array.get(suportresistance, x * 2 + 1))\r\n    array.set(suportresistance, x * 2 + 1, tmp)\r\n    \r\nif ph or pl\r\n    supres = array.new_float(0)  // number of pivot, strength, min/max levels\r\n    stren = array.new_float(10, 0)\r\n    // get levels and strengs\r\n    for x = 0 to array.size(pivotvals) - 1\r\n        [hi, lo, strength] = get_sr_vals(x)\r\n        array.push(supres, strength)\r\n        array.push(supres, hi)\r\n        array.push(supres, lo)\r\n    \r\n    // add each HL to strengh\r\n    for x = 0 to array.size(pivotvals) - 1\r\n        h = array.get(supres, x * 3 + 1)\r\n        l = array.get(supres, x * 3 + 2)\r\n        s = 0\r\n        for y = 0 to loopback\r\n            if (high[y] <= h and high[y] >= l) or\r\n               (low[y] <= h and low[y] >= l)\r\n                s := s + 1\r\n        array.set(supres, x * 3, array.get(supres, x * 3) + s)\r\n    \r\n    //reset SR levels\r\n    array.fill(suportresistance, 0)\r\n    // get strongest SRs\r\n    src = 0\r\n    for x = 0 to array.size(pivotvals) - 1\r\n        stv = -1. // value\r\n        stl = -1 // location\r\n        for y = 0 to array.size(pivotvals) - 1\r\n            if array.get(supres, y * 3) > stv and array.get(supres, y * 3) >= minstrength * 20\r\n                stv := array.get(supres, y * 3)\r\n                stl := y\r\n        if stl >= 0\r\n            //get sr level\r\n            hh = array.get(supres, stl * 3 + 1)\r\n            ll = array.get(supres, stl * 3 + 2)\r\n            array.set(suportresistance, src * 2, hh)\r\n            array.set(suportresistance, src * 2 + 1, ll)\r\n            array.set(stren, src, array.get(supres, stl * 3))\r\n            \r\n            // make included pivot points' strength zero \r\n            for y = 0 to array.size(pivotvals) - 1\r\n                if (array.get(supres, y * 3 + 1) <= hh and array.get(supres, y * 3 + 1) >= ll) or\r\n                   (array.get(supres, y * 3 + 2) <= hh and array.get(supres, y * 3 + 2) >= ll)\r\n                    array.set(supres, y * 3, -1)\r\n\r\n            src += 1\r\n            if src >= 10\r\n                break\r\n    \r\n    for x = 0 to 8\r\n        for y = x + 1 to 9\r\n            if array.get(stren, y) > array.get(stren, x)\r\n                tmp = array.get(stren, y) \r\n                array.set(stren, y, array.get(stren, x))\r\n                changeit(x, y)\r\n                \r\n    \r\nget_level(ind)=>\r\n    float ret = na\r\n    if ind < array.size(suportresistance)\r\n        if array.get(suportresistance, ind) != 0\r\n            ret := array.get(suportresistance, ind)\r\n    ret\r\n    \r\nget_color(ind)=>\r\n    color ret = na\r\n    if ind < array.size(suportresistance)\r\n        if array.get(suportresistance, ind) != 0\r\n            ret := array.get(suportresistance, ind) > close and array.get(suportresistance, ind + 1) > close ? res_col :\r\n                   array.get(suportresistance, ind) < close and array.get(suportresistance, ind + 1) < close ? sup_col :\r\n                   inch_col\r\n    ret\r\n\r\nvar srchannels = array.new_box(10)\r\nfor x = 0 to min(9, maxnumsr)\r\n    box.delete(array.get(srchannels, x))\r\n    srcol = get_color(x * 2)\r\n    if not na(srcol)\r\n        array.set(srchannels, x, \r\n                  box.new(left = bar_index, top = get_level(x * 2), right = bar_index + 1, bottom = get_level(x * 2 + 1), \r\n                          border_color = srcol, \r\n                          border_width = 1,\r\n                          extend = extend.both, \r\n                          bgcolor = srcol))\r\n\r\nresistancebroken = false\r\nsupportbroken = false\r\n\r\n// check if it's not in a channel\r\nnot_in_a_channel = true\r\nfor x = 0 to min(9, maxnumsr)\r\n    if close <= array.get(suportresistance, x * 2) and close >= array.get(suportresistance, x * 2 + 1) \r\n        not_in_a_channel := false\r\n\r\n// if price is not in a channel then check broken ones\r\nif not_in_a_channel\r\n    for x = 0 to min(9, maxnumsr)\r\n        if close[1] <= array.get(suportresistance, x * 2) and close > array.get(suportresistance, x * 2)\r\n            resistancebroken := true\r\n        if close[1] >= array.get(suportresistance, x * 2 + 1) and close < array.get(suportresistance, x * 2 + 1)\r\n            supportbroken := true\r\n\r\nalertcondition(resistancebroken, title = \"Resistance Broken\", message = \"Resistance Broken\")\r\nalertcondition(supportbroken, title = \"Support Broken\", message = \"Support Broken\")\r\nplotshape(showsrbroken and resistancebroken, style = shape.triangleup, location = location.belowbar, color = color.new(color.lime, 0), size = size.tiny)\r\nplotshape(showsrbroken and supportbroken, style = shape.triangledown, location = location.abovebar, color = color.new(color.red, 0), size = size.tiny)\r\n","updated":"2021-10-04T12:26:22.493507Z","version":"5.0"}